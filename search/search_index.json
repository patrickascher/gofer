{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"about/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"about/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"about/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"quickstart/","title":"Getting started","text":"<p>The easiest way to create a simple web app, is to use the gofer-skeleton app.  The skeleton app should give you an idea how to create a web app with the <code>gofer</code> framework.</p>"},{"location":"quickstart/#install-for-development","title":"Install for development","text":"<p>gofer-skeleton offers two ways to install a dev env. Both ways offer a backend and frontend hot reload. For performance reasons I would suggest the local env.</p>"},{"location":"quickstart/#docker-compose","title":"Docker-compose","text":"<p>Requirements:</p> <ul> <li>Docker</li> </ul> <p>Run this command in the application folder.</p> <pre><code>docker-compose up\n</code></pre>"},{"location":"quickstart/#local","title":"local","text":"<p>Requirements:</p> <ul> <li>GO</li> <li>Node.JS</li> <li>DB instance (mysql)</li> </ul> <p>1) import the sql dump file to your mysql instance and define your mysql server in the <code>config.json</code> file (databases).</p> <p>2) Install fresh. Which is a file monitoring tool for GO.</p> <pre><code>go get github.com/gravityblast/fresh\n</code></pre> <p>3) Run the following command in the application folder:</p> <p>Will start the backend(go) hot reload.</p> <pre><code>fresh \n</code></pre> <p>switch to the frontend</p> <pre><code>cd frontend/\nnpm install\nnpm run serve\n</code></pre> <p>The application is now running under localhost:8080</p>"},{"location":"reference/","title":"Welcome to Reference","text":"<p>References are defined in three sections.</p> <ul> <li>Skeleton-App - example app</li> <li>Go - The backend framework</li> <li>Frontend - the frontend implementation</li> </ul>"},{"location":"reference/frontend/alert/","title":"Alert","text":"<p>Will display a VSnackbar with the default settings Timeout <code>5000</code> and Btn <code>true</code>. TODO: config for the framework.</p> <p>A complete axios response can be passed. if a json.error message exists, it will be displayed.</p>"},{"location":"reference/frontend/alert/#alert-modes","title":"Alert modes","text":"Mode <code>ALERT</code>.<code>SUCCESS</code> <code>ALERT</code>.<code>INFO</code> <code>ALERT</code>.<code>ERROR</code>"},{"location":"reference/frontend/alert/#trigger","title":"Trigger","text":"<pre><code> store.commit('alert/' + ALERT.ERROR, \"Message\")\n</code></pre>"},{"location":"reference/frontend/grid/","title":"Grid","text":"<p>TODO </p>"},{"location":"reference/frontend/grid/#used-translation-keys","title":"used translation keys:","text":"Key COMMON.Export COMMON.Add COMMON.DeleteItem COMMON.Export COMMON.Back COMMON.Save COMMON.NoChanges COMMON.NotValid GRID.ItemDeleted GRID.ItemSaved GRID.NoData GRID.LoadingData GRID.XofY GRID.RowsPerPage"},{"location":"reference/frontend/login/","title":"Login","text":"<p>The login has 3 forms.</p> <ul> <li>Login</li> <li>Forgot password</li> <li>Change password</li> </ul> <p>Depending on the provider options <code>forgotPassword</code> or <code>changePassword</code>, these forms are available. If the option is not given, the input fields and buttons are disabled.</p> <p>An application can have one or more auth providers. If there are more than one configured, the user can select the provider in the form. The provider information is added to all the requests for the backend.</p> <p>At the moment the password field must have min 6 chars. TODO: create an option to set custom rules on each field.</p>"},{"location":"reference/frontend/login/#api-calls","title":"API calls","text":"Func Pattern Description login /login (POST) sends the param <code>login</code>,<code>password</code> and <code>provider</code> to the backend. changePw /pw/change (POST) token,login,pw and provider as a param. forgotPassword /pw/forgot (POST) login and provider as a param."},{"location":"reference/frontend/login/#translations","title":"Translations","text":"<p>Used translation keys:</p> Keys <code>CONTROLLER.auth.Controller.Login.Description</code> <code>CONTROLLER.auth.Controller.Login.ForgotPassword</code> <code>CONTROLLER.auth.Controller.Login.Privacy</code> <code>CONTROLLER.auth.Controller.Login.Impress</code> <code>CONTROLLER.auth.Controller.Login.ErrPasswordLength</code> <code>CONTROLLER.auth.Controller.Login.ErrPasswordRequired</code> <code>CONTROLLER.auth.Controller.Login.ErrPasswordMatch</code> <code>CONTROLLER.auth.Controller.Login.ErrLoginRequired'</code> <code>CONTROLLER.{{provider}}.ChangePassword.Success</code> <code>CONTROLLER.{{provider}}.ChangePassword.Info</code> <code>CONTROLLER.{{provider}}.ForgotPassword.Success</code> <code>CONTROLLER.{{provider}}.ForgotPassword.Info</code> <code>COMMON.Login</code> <code>COMMON.Password'</code> <code>COMMON.PasswordConfirm'</code> <code>COMMON.Save'</code> <code>COMMON.Reset</code> <code>COMMON.Back</code>"},{"location":"reference/frontend/translate/","title":"Translate","text":"<p>The translations are checked in the folder <code>lang</code>. The files must be in the pattern <code>{lang}.json</code>. They are lazy loaded by the application.</p>"},{"location":"reference/frontend/translate/#usage","title":"Usage","text":"<p>Usage of the translation keys.</p> <pre><code>$t('MessageID')\n</code></pre>"},{"location":"reference/frontend/translate/#api","title":"api","text":"Pattern Method Description <code>/mode/overview</code> <code>GET</code> will return the raw messages, available laguages, translated languages and the groups. <code>/lang/{lang}/group/{group}</code> <code>PUT</code> will create / update the group for this language. The json files will be updated. <code>/lang/{lang}</code> <code>DELETE</code> will delete the language. The json files will be deleted. <code>/lang/{lang}.json</code> <code>GET</code> return the json content."},{"location":"reference/frontend/translate/#used-tranlsation-keys","title":"used tranlsation keys:","text":"Key COMMON.Language COMMON.Close COMMON.Add COMMON.Delete COMMON.Save COMMON.NoChanges COMMON.DeleteItem CONTROLLER.locale.Controller.Translation.AddLanguage CONTROLLER.locale.Controller.Translation.Translation CONTROLLER.locale.Controller.Translation.ID CONTROLLER.locale.Controller.Translation.Title CONTROLLER.locale.Controller.Translation.Description"},{"location":"reference/frontend/translate/#i18nservice","title":"I18nService","text":"<p>A service is defined which can be used by a vue app.</p> <pre><code>import {I18nService} from 'gofer-vue'\n\nlet i18n = I18nService.i18n\nnew Vue({\n    i18n,\n    render: h =&gt; h(App)\n}).$mount('#app')\n</code></pre> <p>The service has the option to lazy load languages. If a language was already loaded, no server request will be made. Anyways, if you need to force a reload, set the second param to true.</p> <pre><code>import {I18nService} from 'gofer-vue'\n\nI18nService.loadLanguageAsync(\"en\", false)\n</code></pre> <p>Can simple be used in <code>router.beforeEach</code>:</p> <pre><code>router.beforeEach((to, from, next) =&gt; {\n    const lang = to.params.lang\n    I18nService.loadLanguageAsync(lang, false).then(() =&gt; next())\n})\n</code></pre>"},{"location":"reference/go/auth/","title":"Auth","text":"<p>Package auth provides a standard auth for your website. Custom auth providers can be added. Simply implement the <code>auth.Interface</code></p>"},{"location":"reference/go/auth/#new","title":"New","text":"<p>The <code>New</code> function requires the provider name as argument.</p> <p>Error will return if the provider was not registered or configure before.</p> <pre><code>// Example of the memory cache provider\nprovider, err := auth.New(\"native\")\n</code></pre>"},{"location":"reference/go/auth/#configureprovider","title":"ConfigureProvider","text":"<p>Warning</p> <p>A provider must have a map value in the json config. Maps with only a defined key will be irgnored at the moment. If you dont have any options, define <code>{foo:\"bar\"}</code> or something. The error has to get fixed in the config package.</p> <p>Must be used to configure the provider on webserver start. Because there can be different providers with different configurations, a map is passed as second argument. Please see the provider section for the different configuration parameters.</p> <pre><code>err := ConfigureProvider(\"native\", nil)\n//...\n</code></pre>"},{"location":"reference/go/auth/#config","title":"Config","text":"<p>The config is predefined in <code>Server.Configuration.Auth</code>.</p> Name Description BcryptCost bcrypt cost AllowedFailedLogin number of failed login attempts before the user gets locked. LockDuration defines how long a user should be locked before the next login attempt is allowed. (RFC3339 duration string) InactiveDuration the allowed duration between the last login and now (RFC3339  duration string) TokenDuration JWT token live time (RFC3339  duration string) RefreshTokenDuration Refresh token live time (RFC3339  duration string)"},{"location":"reference/go/auth/#controller","title":"Controller","text":"<p>The <code>auth.Controller</code> can be used out of the box. All required routes can be added with the helper function <code>auth.AddRoutes</code>.</p> <p>If you need to extend the controller, simply embed it into your controller and extend the functions.</p>"},{"location":"reference/go/auth/#protocol","title":"Protocol","text":"<p>A Protocol is added which loggs the following user actions:</p> <ul> <li>Login</li> <li>Enter wrong password</li> <li>Locked user</li> <li>Inactive user</li> <li>Refresh Token</li> <li>Refresh Token failed</li> <li>Logout</li> <li>Reset password</li> </ul> <p>If you need to add additional protocols, use the helper function <code>AddProtocol(userID,key,value)</code></p>"},{"location":"reference/go/auth/#claim","title":"Claim","text":"<p>By default, the user claim which will be included in the jwt token looks like this. It can be fully customized but be aware to re-implement the <code>jwt.CallbackGenerate</code> and <code>jwt.CallbackRefresh</code> for your requirements.</p> <pre><code>type Claim struct {\njwt.Claim\n\nProvider string `json:\"provider\"`\nUserID   int    `json:\"id\"`\n\nName    string   `json:\"name\"`\nSurname string   `json:\"surname\"`\nLogin   string   `json:\"login\"`\nRoles   []string `json:\"Roles\"`\n\nOptions map[string]string `json:\"options\"`\n}\n</code></pre>"},{"location":"reference/go/auth/#jwt-middleware","title":"JWT middleware","text":"<p>There are two pre-defined callbacks for the jwt middleware <code>JWTRefreshCallback</code> and <code>JWTGenerateCallback</code>. Which can be used out of the box.</p>"},{"location":"reference/go/auth/#rbac-middleware","title":"RBAC middleware","text":"<p>A pre-defined rbac middleware can be used out of the box.</p>"},{"location":"reference/go/auth/#providers","title":"Providers","text":""},{"location":"reference/go/auth/#native","title":"Native","text":"<p>The native provider will connect to the existing user database. It will add an user option <code>password</code> for the authentication.</p>"},{"location":"reference/go/auth/#create-your-own-provider","title":"Create your own provider","text":"<p>To create your own provider, you have to implement the <code>auth.Interface</code>.</p> <pre><code>type Interface interface {\nLogin(p controller.Interface) (Schema, error)\nLogout(p controller.Interface) error\nRecoverPassword(p controller.Interface) error\n}\n</code></pre> <p>Use the <code>init</code> function to register your provider.</p> <p>The registered value must be of the type <code>func(opt map[string]interface{}) (Interface, error)</code>.</p> <pre><code>// init register the superFastMemory provider.\nfunc init() {\n    err := auth.Register(\"yourProvider\", func(options map[string]interface{}) (auth.Interface, error) { return &amp;yourProvider{}, nil })\n    if err != nil {\n        panic(err)\n    }\n}\n\ntype yourProvider struct {\n}\n\nfunc (n *Native) Login(c controller.Interface) (auth.Schema, error) {\n//...\n}\n</code></pre>"},{"location":"reference/go/auth/#schema","title":"Schema","text":"<p>A Schema is defined which must be used from all providers. Options will be saved in the user database (not yet implemented). The Login will be mapped with the local user database.</p> <pre><code>type Schema struct {\nProvider string\nUID      string\n\nLogin      string\nName       string\nSurname    string\nSalutation string\n\nOptions []Option\n}\n</code></pre>"},{"location":"reference/go/cache/","title":"Cache","text":"<p>Package cache provides a cache manager for any type that implements the <code>cache.Interface</code>. It is developer friendly, offers additional prefixing and functions for hit/miss statistics.</p>"},{"location":"reference/go/cache/#usage","title":"Usage","text":"<p>Inspired by the <code>database/sql</code>, this module is based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section.</p> <pre><code>import \"github.com/patrickascher/gofer/cache\"\nimport _ \"github.com/patrickascher/gofer/cache/memory\"\n</code></pre>"},{"location":"reference/go/cache/#new","title":"New","text":"<p>The <code>New</code> function requires two arguments. First the name of the registered provider and a provider configuration. Each provider will have different configuration settings, please see the providers section for more details.</p> <p>Error will return if the provider was not found or registered before.</p> <pre><code>// Example of the memory cache provider\nmem, err := cache.New(cache.MEMORY, nil)\n</code></pre>"},{"location":"reference/go/cache/#setdefaultprefix","title":"SetDefaultPrefix","text":"<p>Set a default prefix for all cache items which will be set with <code>cache.DefaultPrefix</code>.</p> <pre><code>mem.SetDefaultPrefix(\"session\")\n</code></pre>"},{"location":"reference/go/cache/#setdefaultexpiration","title":"SetDefaultExpiration","text":"<p>Set a default expiration for all cache items which will be set with <code>cache.DefaultExpiration</code>.</p> <pre><code>mem.SetDefaultExpiration(5*time.Hour)\n</code></pre>"},{"location":"reference/go/cache/#exist","title":"Exist","text":"<p>Exist wraps the <code>Get()</code> function and will return a boolean instead of an error.</p> <pre><code>exists := mem.Exist(\"name\")  // Boolean\n</code></pre>"},{"location":"reference/go/cache/#get-prefix-all","title":"Get, Prefix, All","text":"<p>Get one or more cached items. Error will return if the cache item / prefix does not exist.</p> <pre><code>// get a single cached item.\nitem,err := mem.Get(cache.DefaultPrefix,\"name\")  // (Item, error)\n\n// get all cached items with the prefix \"session\"\nitem,err := mem.Prefix(\"session\") // ([]Item, error)\n\n// get all cached items\nitem,err := mem.All()    // ([]Item, error)\n</code></pre>"},{"location":"reference/go/cache/#set","title":"Set","text":"<p>Set a cache item by prefix, name, value and expiration.</p> <p>Infinity live time</p> <p>If you need no expiration for a cache item, use <code>cache.NoExpiration</code>.</p> <pre><code>// the managers default expiration time. \nerr := mem.Set(cache.DefaultPrefix,\"name\",\"value\",cache.DefaultExpiration)\n\n// custom expiration time and prefix.\nerr := mem.Set(\"session\",\"name\",\"value\",5*time.Hour)\n\n// no expiration.\nerr := mem.Set(cache.DefaultPrefix,\"name\",\"value\",cache.NoExpiration)\n</code></pre>"},{"location":"reference/go/cache/#delete-deleteprefix-deleteall","title":"Delete, DeletePrefix, DeleteAll","text":"<p>Delete one or more cached items. Error will return if the cache item / prefix does not exist.</p> <pre><code>// delete the item by key\nerr := mem.Delete(cache.DefaultPrefix,\"name\")\n\n// delete all items with the prefix \"session\"\nerr := mem.DeletePrefix(\"session\")\n\n// delete all cached items\nerr := mem.DeleteAll()\n</code></pre>"},{"location":"reference/go/cache/#hitcount","title":"HitCount","text":"<p>Statistics how often the cache item was hit.</p> <pre><code>err := mem.HitCount(cache.DefaultPrefix,\"user\")\n</code></pre>"},{"location":"reference/go/cache/#misscount","title":"MissCount","text":"<p>Statistics how often the cache item was missed.</p> <pre><code>err := mem.MissCount(cache.DefaultPrefix,\"user\")\n</code></pre>"},{"location":"reference/go/cache/#providers","title":"Providers","text":"<p>All pre-defined providers:</p>"},{"location":"reference/go/cache/#memory","title":"Memory","text":"<p>A simple in memory cache.</p> <p>Name:</p> <p><code>cache.MEMORY</code></p> <p>Options:</p> Option Description <code>GCInterval</code> time.Duration how often the GC should run in a loop. <p>Usage:</p> <pre><code>import \"github.com/patrickascher/gofer/cache\"\nimport _ \"github.com/patrickascher/gofer/cache/memory\"\n\nmem, err := cache.Manager(cache.MEMORY, nil)\n</code></pre>"},{"location":"reference/go/cache/#create-your-own-provider","title":"Create your own provider","text":"<p>To create your own provider, you have to implement the <code>cache.Interface</code>.</p> <pre><code>type Interface interface {\n// Get returns an Item by its name.\n// Error must returns if it does not exist.\nGet(name string) (Item, error)\n// All cached items.\n// Must returns nil if the cache is empty.\nAll() ([]Item, error)\n// Set an item by its name, value and lifetime.\n// If cache.NoExpiration is set, the item should not get deleted.\nSet(name string, value interface{}, exp time.Duration) error\n// Delete a value by its name.\n// Error must return if it does not exist.\nDelete(name string) error\n// DeleteAll items.\nDeleteAll() error\n// GC will be called once as goroutine.\n// If the cache backend has its own garbage collector (redis, memcached, ...) just return void in this method.\nGC()\n} \n</code></pre> <p>Use the <code>init</code> function to register your provider.</p> <p>The registered value must be of the type <code>func(interface {}) (cache.Interface, error)</code>.</p> <pre><code>// init register the superFastMemory provider.\nfunc init() {\n    err := cache.Register(\"superFastMemory\", New)\n    if err != nil{\n        log.Fatal(err)\n    }\n}\n\n// New creates a super-fast-memory type which implements the cache.Interface.\nfunc New(opt interface{}) (cm.Interface,error) {\n    //...\n    return &amp;superFastMemory{},nil\n}\n</code></pre> <p>Usage</p> <pre><code>import \"github.com/patrickascher/gofer/cache\"\nimport _ \"your/repo/cache/superFastMemory\"\n\nmemoryProvider, err := cache.Manager(\"superFastMemory\", nil)\n</code></pre>"},{"location":"reference/go/config/","title":"Config","text":"<p>Package config provides a config manager for any type that implements the <code>config.Interface</code>. It will load the parsed values into a configuration struct.</p> <p>Supports JSON, TOML, YAML, HCL, INI, envfile and Java properties config files (viper provider). Every provider has its own options, please see the providers section for more details.</p> <p>It also offers automatically config reload if the underlaying file changes and offers a callback function.</p>"},{"location":"reference/go/config/#usage","title":"Usage","text":"<p>Inspired by the <code>database/sql</code>, this module is based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section.</p> <pre><code>import \"github.com/patrickascher/gofer/config\"\nimport _ \"github.com/patrickascher/gofer/config/viper\" // example for the viper provider\n</code></pre>"},{"location":"reference/go/config/#load","title":"Load","text":"<pre><code>type Config struct{\n    Host string\n    User string\n    //....\n}\n\n// provider options\noptions := viper.Options{FileName:\"config.json\",FilePath:\".\",FileType:\"json\"}\n// config struct\ncfg := Config{}\n\n// Load the configuration.\nerr = config.Load(config.VIPER,&amp;cfg,options)\n\n// cfg will have the loaded values\n</code></pre>"},{"location":"reference/go/config/#providers","title":"Providers","text":"<p>All pre-defined providers:</p>"},{"location":"reference/go/config/#viper","title":"Viper","text":"<p>A wrapper for viper.</p> <p>This provider can load JSON, TOML, YAML, HCL, INI, envfile and Java properties config files.</p> <p>A watcher can be added to reload the configuration file on changes. Additional callback can be set.</p> <p>!!! Info By default, the configuration struct will be updated if the config file changes.</p> <p>Name:</p> <p><code>config.VIPER</code></p> <p>Options:</p> Option Description <code>FileName</code> <code>string</code> Name of the config file. Mandatory <code>FileType</code> <code>string</code> Type of the config file. Mandatory <code>FilePath</code> <code>string</code> Path of the config file. Use <code>.</code> for the working directory. Mandatory <code>Watch</code> <code>bool</code> Watch the config file for changes. <code>WatchCallback</code> <code>func(cfg interface{}, viper *viper.Viper, e fsnotify.Event)</code> Callback function which will be triggered if the watcher is activated and a file change happens. <code>EnvPrefix</code> <code>string</code> Env prefix. <code>EnvAutomatic</code> <code>bool</code> All env variables will be mapped if the config struct key exists. <code>EnvBind</code> <code>[]string</code> Only the defined env variables will be mapped if they exist in the config struct. <p>Usage:</p> <pre><code>import \"github.com/patrickascher/gofer/config\"\nimport _ \"github.com/patrickascher/gofer/config/viper\"\n\ntype Config struct{\n    Host string\n    User string\n    //....\n}\n\n// options\noptions := viper.Options{\n    FileName:\"config.json\",\n    FilePath:\".\",\n    FileType:\"json\",\n    Watch:true,\n    WatchCallback:fileChangedCallback\n}\n\nfunc fileChangedCallback(cfg interface{}, viper *viper.Viper, e fsnotify.Event){\n    // on change, do something\n}\n\n// config struct\ncfg := Config{}\n\n// Load the configuration.\nerr = config.Load(config.VIPER,&amp;cfg,options)\n// cfg will have the loaded values\n</code></pre>"},{"location":"reference/go/config/#create-your-own-provider","title":"Create your own provider","text":"<p>To create your own provider, you have to implement the <code>config.Interface</code>.</p> <pre><code>type Interface interface {\n    Parse(config interface{}, options interface{}) error\n}\n</code></pre> <p>Use the <code>init</code> function to register your provider.</p> <p>The registered value must be of the type <code>config.Interface</code>.</p> <pre><code>// init register your config provider\nfunc init() {\n    err := registry.Set(\"your-config-provider\", new(yourProvider))\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\ntype yourProvider struct{}\n\n// New creates a super-fast-memory type which implements the cache.Interface.\nfunc (p *yourProvider) Parse(cfg interface{}, opt interface{}) error {\n    // parse something\n}\n</code></pre> <p>Usage</p> <pre><code>import \"github.com/patrickascher/gofer/cache\"\nimport _ \"your/repo/config/yourProvider\"\n\ntype Config struct{\n    Host string\n    User string\n    //...\n}\n\n// configuration struct\ncfg := Config{}\n\n// your provider options, if you dont need any, just add nil as argument.\noptions := YourProviderOptions{}\n\nerr := config.Load(\"your-config-provider\", &amp;cfg, options)\n</code></pre>"},{"location":"reference/go/controller/","title":"Controller","text":"<p>Package controller provides a controller / action based <code>http.Handler</code> for the router.</p> <p>A controller can have different renderer and is easy to extend.</p> <p>Data, redirects and errors can be set directly in the controller. A context with some helpers for the response and request is provided.</p>"},{"location":"reference/go/controller/#usage","title":"Usage","text":"<p>Controller can be easy extended and added as route. You only need to embed the <code>controller.Base</code>.</p> <pre><code>type MyController struct{\n    constroller.Base\n}\n\nfunc (c MyController) User(){\n    // logic\n} \n\n// add controller to router with the mapping HTTP GET calls MyController.User()\nmyController := MyController{}\nerr = r.AddSecureRoute(router.NewRoute(\"/user\", &amp;myController, router.NewMapping([]string{http.MethodGet}, myController.User, nil)))\n</code></pre>"},{"location":"reference/go/controller/#initialize","title":"Initialize","text":"<p>Initialize is used to set the struct reference. This is called automatically by the router.</p> <pre><code>c := MyController{}\nc.Initialize(&amp;c)\n</code></pre>"},{"location":"reference/go/controller/#action","title":"Action","text":"<p>Return the requested Action name.</p>"},{"location":"reference/go/controller/#name","title":"Name","text":"<p>Returns the controller name incl. the package name.</p>"},{"location":"reference/go/controller/#rendertype","title":"RenderType","text":"<p>Returns the render type. Default <code>json</code>.</p>"},{"location":"reference/go/controller/#setrendertype","title":"SetRenderType","text":"<p>Set a custom render type.</p>"},{"location":"reference/go/controller/#set","title":"Set","text":"<p>Is a helper to set controller variables. It wraps the context.Response.SetValue.</p>"},{"location":"reference/go/controller/#translation-t-tp","title":"Translation (T, TP)","text":"<p>If configured, a i18n translation can be used like this.</p> <pre><code>// for single messages\nctrl.T(\"MessageID\")\n\n// for plural or count depending messages\nctrl.TP(\"MessageID\",2)\n\n// if in your message you are using placeholders, you can add the data as map:\n//  MessageID -&gt; One: \"{{.Name}} has {{.Count}} cat.\",\n//  MessageID -&gt; Other: \"{{.Name}} has {{.Count}} cats.\",\n\nctrl.TP(\"MessageID\",1,map[string]interface{}{\"Name\":\"John\",\"Count\":1})\n// will return: John has 1 cat. \n\nctrl.TP(\"MessageID\",2,map[string]interface{}{\"Name\":\"John\",\"Count\":2})\n// will return: John has 2 cats. \n</code></pre>"},{"location":"reference/go/controller/#error","title":"Error","text":"<p>Is a helper to set an error. If an error ist set, all defined values will be deleted. It wraps the context.Response.Error.</p>"},{"location":"reference/go/controller/#redirect","title":"Redirect","text":"<p>Redirect to an URL. On a redirect the old controller data will be lost.</p>"},{"location":"reference/go/controller/#servehttp","title":"ServeHTTP","text":"<p>Implements the <code>http.Handler</code> interface.</p> <p>It creates a new instance of the requested controller and creates a new context.</p> <p>It checks if a action name is available and checks if a function with that name exists and calls it. If not, an error will return.</p> <p>Between the <code>Action</code> and `Render call, it checks if the Browser is still connected. Otherwise the request will be cancelled.</p> <p>If the controller has no custom set Error, the Render function will be called.</p>"},{"location":"reference/go/controller/#setcontext","title":"SetContext","text":"<p>Set a context to the controller.</p>"},{"location":"reference/go/controller/#context","title":"Context","text":"<p>Context provides some useful helper for the <code>Request</code> and <code>Response</code>.</p>"},{"location":"reference/go/controller/#request","title":"Request","text":""},{"location":"reference/go/controller/#body","title":"Body","text":"<p>Returns the raw body data.</p>"},{"location":"reference/go/controller/#setbody","title":"SetBody","text":"<p>Can be used to manipulate the body data.</p>"},{"location":"reference/go/controller/#localizer","title":"Localizer","text":"<p>Returns the controller localizer.</p>"},{"location":"reference/go/controller/#pattern","title":"Pattern","text":"<p>Returns the router url pattern.</p> <p>Example: <code>http://example.com/user/1</code> will return <code>/user/:id</code></p>"},{"location":"reference/go/controller/#httprequest","title":"HTTPRequest","text":"<p>Returns the original <code>*http.Request</code>.</p>"},{"location":"reference/go/controller/#jwtclaim","title":"JWTClaim","text":"<p>A helper to return the claim set by the request context.</p>"},{"location":"reference/go/controller/#method","title":"Method","text":"<p>Returns the HTTP method in uppercase.</p>"},{"location":"reference/go/controller/#is","title":"Is","text":"<p>Compares the given method with the request HTTP method.</p> <pre><code>if r.Is(http.MethodGet){\n//...\n}\n</code></pre>"},{"location":"reference/go/controller/#issecure","title":"IsSecure","text":"<p>Returns true if the request is <code>https</code>.</p>"},{"location":"reference/go/controller/#isget","title":"IsGet","text":"<p>Checks if the request is a <code>http.MethodGet</code>.</p>"},{"location":"reference/go/controller/#ispost","title":"IsPost","text":"<p>Checks if the request is a <code>http.MethodPost</code>.</p>"},{"location":"reference/go/controller/#ispatch","title":"IsPatch","text":"<p>Checks if the request is a <code>http.MethodPatch</code>.</p>"},{"location":"reference/go/controller/#isput","title":"IsPut","text":"<p>Checks if the request is a <code>http.MethodPut</code>.</p>"},{"location":"reference/go/controller/#isdelete","title":"IsDelete","text":"<p>Checks if the request is a <code>http.MethodDelete</code>.</p>"},{"location":"reference/go/controller/#param","title":"Param","text":"<p>Returns a parameter by key. It returns a <code>[]string</code> because the underlying HTML input field could be an array. Error will return on internal error or if the key does not exist.</p> <pre><code>p, err := r.Param(\"user\")\n</code></pre>"},{"location":"reference/go/controller/#params","title":"Params","text":"<p>Returns all existing parameters. It returns a <code>map[string][]string</code> because the underlying HTML input field could be an array. Error will return on internal error.</p>"},{"location":"reference/go/controller/#ip","title":"IP","text":"<p>IP of the request.</p>"},{"location":"reference/go/controller/#proxy","title":"Proxy","text":"<p>Return all IPs which are in the X-Forwarded-For header.</p>"},{"location":"reference/go/controller/#scheme","title":"Scheme","text":"<p>Scheme (http/https) checks the <code>X-Forwarded-Proto</code> header. If that one is empty the URL.Scheme gets checked. If that is also empty the request TLS will be checked.</p>"},{"location":"reference/go/controller/#host","title":"Host","text":"<p>Returns the host name. Port number will be removed. If no host info is available, localhost will return.</p> <p><code>https://example.com:8080/user?id=12#test</code> will return <code>example.com</code>.</p>"},{"location":"reference/go/controller/#protocol","title":"Protocol","text":"<p>Returns the protocol name, such as HTTP/1.1.</p>"},{"location":"reference/go/controller/#uri","title":"URI","text":"<p>Returns full request url with query string fragment.</p> <p><code>https://example.com:8080/user?id=12#test</code> will return <code>/user?id=12#test</code>.</p>"},{"location":"reference/go/controller/#url","title":"URL","text":"<p>Returns request url path without the query string and fragment.</p> <p><code>https://example.com:8080/user?id=12#test</code> will return <code>/user</code></p>"},{"location":"reference/go/controller/#fullurl","title":"FullURL","text":"<p>Returns the schema,host,port,uri.</p> <p><code>https://example.com:8080/user?id=12#test</code> will return <code>https://example.com:8080/user?id=12#test</code>.</p>"},{"location":"reference/go/controller/#site","title":"Site","text":"<p>Returns base site url as <code>scheme://domain</code> type without the port.</p> <p><code>https://example.com:8080/user?id=12#test</code> will return <code>https://example.com</code>.</p>"},{"location":"reference/go/controller/#domain","title":"Domain","text":"<p>Is an alias for Host.</p>"},{"location":"reference/go/controller/#port","title":"Port","text":"<p>Will return the port of the request. If it is empty, 80 will return as default.</p>"},{"location":"reference/go/controller/#referer","title":"Referer","text":"<p>Returns the Referer Header.</p>"},{"location":"reference/go/controller/#response","title":"Response","text":"<p>Is a helper to set data and to render the content. A custom render provider can be created, simply implement the <code>Renderer</code> interface.</p>"},{"location":"reference/go/controller/#setvalue","title":"SetValue","text":"<p>Set a value by key/value pair.</p>"},{"location":"reference/go/controller/#value","title":"Value","text":"<p>Value by the key. If the key does not exist, nil will return.</p>"},{"location":"reference/go/controller/#values","title":"Values","text":"<p>Returns all defined values.</p>"},{"location":"reference/go/controller/#resetvalues","title":"ResetValues","text":"<p>Reset all defined values.</p>"},{"location":"reference/go/controller/#writer","title":"Writer","text":"<p>Returns the <code>*http.ResponseWriter</code>.</p>"},{"location":"reference/go/controller/#render","title":"Render","text":"<p>Render will render the content by the given render type. An error will return if the render provider does not exist or the renders write function returns one.</p>"},{"location":"reference/go/controller/#error_1","title":"Error","text":"<p>Error will render the error message by the given render type. An error will return if the render provider does not exist or the renders error function returns one.</p>"},{"location":"reference/go/controller/#create-your-own-render-provider","title":"Create your own render provider","text":"<p>To create your own render provider, you have to implement the <code>controller.Renderer</code> interface.</p>"},{"location":"reference/go/controller/#checkbrowsercancellation-callaction-haserror","title":"CheckBrowserCancellation, CallAction, HasError","text":"<p>TODO docu, just added because of ther unexported interface and mocking problem.</p> <pre><code>// Renderer interface for the render providers.\ntype Renderer interface {\nName() string\nIcon() string\nWrite(response *Response) error\nError(response *Response, code int, err error) error\n}\n</code></pre> <p>Use the <code>init</code> function to register your provider.</p> <pre><code>// init register your render provider\nfunc init() {\n    //...\n    err := controller.RegisterRenderer(\"xml\",newXmlRenderer)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\ntype xmlRenderer struct{}\n\nfunc newXmlRenderer() (Renderer, error) {\n    return &amp;xmlRenderer{}, nil\n}\n\n// ... render functions\n</code></pre> <p>Usage</p> <pre><code>import \"github.com/patrickascher/gofer/controller\"\nimport _ \"your/repo/controller/renderer\"\n\n// somewhere in your controller\nc.SetRenderType(\"xml\")\n</code></pre>"},{"location":"reference/go/grid/","title":"Grid","text":"<p>The grid package converts any <code>grid.Source</code> into a CRUD backend.</p> <ul> <li>All primary-, foreign, references and polymorphic fields are removed by default</li> <li>Relation will be displayed depth max 1 at the moment.</li> <li><code>belongsTo</code> and <code>manyToMany</code> will be select boxes on the frontend.</li> <li>Errors will be set as controller errors.</li> <li>Field validation will happen automatically on front- and backend.</li> <li>Frontend fields will be rendered automatically by field type.</li> <li>Developer friendly. Every source which implements the <code>grid.Source</code> can be used.</li> </ul>"},{"location":"reference/go/grid/#usage","title":"Usage","text":"<pre><code>func (c MyController) User(){\n    g := grid.New(c,grid.Orm(model),nil)\n    //...\n    g.Render()\n} \n</code></pre>"},{"location":"reference/go/grid/#new","title":"New","text":"<p>Creates a new grid instance. The first argument must be the <code>controller</code>, the second is the <code>grid.Source</code> and the third is the <code>grid.config</code> which is optional.</p> <p>The grid will be cached, to avoid re-creating the grid fields. The cache key will be the configured grid ID. Be aware that the config will be cached. If you need dynamic configuration, use <code>grid.Scope().Config</code> for it, after init.</p> <pre><code>g := grid.New(c, grid.Orm(model))\n</code></pre>"},{"location":"reference/go/grid/#config","title":"Config","text":"<p>The grid can be fully configured. If the configuration should be changed after init dynamically, the <code>Scope.Config()</code> can be used.</p> Name Default Description ID <code>controller:action</code> Unique name for the grid. This is used as cache key. Title <code>{ID}-title</code> Title of the grid. Description <code>{ID}-description</code> Description of the grid. Policy <code>orm.WHITELIST</code> If the Policy is <code>WHITELIST</code>, the fields have to be set explicit. Exports <code>csv</code> Slice of names of render types. Action see ACTION Filter see FILTER History see HISTORY <p>Action</p> Name Default Description PositionLeft <code>false</code> Defines where the action (details,edit,delete) column should be displayed on the grid table. DisableDetails <code>true</code> Disables the details mode. It is disabled because its not implemented yet! DisableCreate <code>false</code> Disables the create mode. DisableUpdate <code>false</code> Disables the update mode. DisableDelete <code>false</code> Disables the delete mode. CreateLinks <code>nil</code> You can add params to the grid Add button. IF multiple entries exist, a menu will be generated. <p>Filter</p> Name Default Description Disable <code>false</code> Disable filter. DisableQuickFilter <code>false</code> Disable the quick filter. DisableCustomFilter <code>false</code> Disable the custom filter. OpenQuickFilter <code>false</code> The quick filter will be opened by default AllowedRowsPerPage <code>-1</code>,<code>5</code>,<code>10</code>,<code>15</code>,<code>25</code>,<code>50</code> The allowed rows per page. RowsPerPage <code>15</code> Default rows per page. <p>History</p> Name Default Description Disable <code>false</code> Disable the history. AdditionalIDs <code>[]string{}</code> Additional grid IDs can be added to show in the history content."},{"location":"reference/go/grid/#mode","title":"Mode","text":"<p>The grid mode is defined by the <code>http.Method</code> and <code>controller.Params</code>.</p> Mode http.Method Param <code>grid.FeTable</code> <code>GET</code> <code>grid.FeHistory</code> <code>GET</code> <code>mode=history</code> <code>grid.FeFilter</code> <code>GET</code> <code>mode=filter</code> <code>grid.SrcCallback</code> <code>GET</code> <code>mode=callback</code> <code>grid.FeDetails</code> <code>GET</code> <code>mode=details</code> <code>grid.FeCreate</code> <code>GET</code> <code>mode=create</code> <code>grid.FeUpdate</code> <code>GET</code> <code>mode=update</code> <code>grid.FeExport</code> <code>GET</code> <code>mode=export</code> <code>grid.SrcCreate</code> <code>POST</code> <code>grid.SrcUpdate</code> <code>PUT</code> <code>grid.SrcDelete</code> <code>DELETE</code>"},{"location":"reference/go/grid/#field","title":"Field","text":"<p>Will return the grid field by name. If the field does not exist, an empty field with an error will return.</p> <pre><code>field := grid.Field(\"ID\")\n</code></pre> <p>A field can be configured by the following functions. Each function returns itself, this way it can be chained. If an error occures, the fields error will be set. Error will be handled in <code>grid.Render</code>.</p> <p>The configuration for <code>SetPosition</code>, <code>SetTitle</code>, <code>SetDescription</code>, <code>SetRemove</code>, <code>SetHidden</code> and <code>SetView</code> must be set with <code>grid.NewValue()</code> or native go type.</p> <ul> <li><code>string</code> for <code>SetTitle</code>, <code>SetDescription</code>, <code>SetView</code></li> <li><code>bool</code> for <code>SetRemove</code>, <code>SetHidden</code></li> <li><code>int</code> for <code>SetPosition</code></li> </ul> <p>If the native type is different, an error will be set.</p> <pre><code>grid.Field(\"ID\").SetTitle(grid.NewValue(\"ID\").SetDetails(\"Identifier\"))\n// grid mode: table, update, create will have the title \"ID\" \n// and details will have the title \"Identifier\".\n</code></pre> Function available frontend Description <code>Name</code>, <code>SetName</code> x Will set the fields name. The name is used in the frontend as id. <code>Primary</code>, <code>SetPrimary</code> x Will define if the field is a primary key. <code>Type</code>, <code>SetType</code> x Defines the field type. <code>Title</code>, <code>SetTitle</code> x Will set the fields title. <code>Description</code>, <code>SetDescription</code> x Will set the fields description. <code>Position</code>, <code>SetPosition</code> x Will set the fields position. <code>Removed</code>, <code>SetRemove</code> x Will flag the field as removed. <code>Hidden</code>, <code>SetHidden</code> x Will set the field as hidden. <code>View</code>, <code>SetView</code> x Will set a custom frontend view component for the field. <code>ReadOnly</code>, <code>SetReadOnly</code> x Will set the field as read only. <code>Sort</code>, <code>SetSort</code> x Will allow the sorting of the field and set the condition field name. <code>Filter</code>, <code>SetFilter</code> x Will allow the filtering of the field and set the condition operator and field name. <code>GroupAble</code>, <code>SetGroupAble</code> x Will set the field as group able. <code>Options</code>, <code>Option</code>, <code>SetOption</code> x Will add a option for the field. <code>Relation</code>, <code>SetRelation</code> x Will define the field as relation <code>Field</code> Will return a field by name. If the field was not found, an field error will be set. (relation) <code>Fields</code>, <code>SetFields</code> x Will return all child fields. (relation) <code>Error</code> Will return the field error. <p>Field types</p> Name implemented in frontend Description <code>Bool</code> Checkbox <code>Integer</code> Input-Integer <code>Float</code> Input-Numeric <code>Text</code> Input-Text <code>TextArea</code> TextArea <code>Time</code> Input <code>Date</code> Datepicker <code>DateTime</code> Datepicker+Input <code>Select</code> Select <code>MultiSelect</code> Select <code>belongsTo</code> Select <code>hasOne</code> Inputs <code>hasMany</code> Inputs <code>m2m</code> Select <p>Options</p> Name value Description <code>DecoratorOption</code> <code>string</code>,<code>string</code> a field name can be used {{Name}}. As second param a separator can be set - if set the FE escaping will be disabled. <p>Callbacks</p> Name value Description <code>Select</code> <code>?</code> <p>TODO: Validate</p>"},{"location":"reference/go/grid/#scope","title":"Scope","text":"<p>The scope will return some helper functions.</p>"},{"location":"reference/go/grid/#source","title":"Source","text":"<p>Will return the grid source.</p> <pre><code>src := scrope.Source()\n</code></pre>"},{"location":"reference/go/grid/#config_1","title":"Config","text":"<p>Will return a pointer to the grid config. For dynamically configuration of the grid.</p> <pre><code>cfg := scrope.Config()\n</code></pre>"},{"location":"reference/go/grid/#fields","title":"Fields","text":"<p>Will return all configured grid fields.</p> <pre><code>fields := scrope.Fields()\n</code></pre>"},{"location":"reference/go/grid/#primaryfields","title":"PrimaryFields","text":"<p>Will return all defined primary fields of the grid.</p> <pre><code>primaryFields := scrope.PrimaryFields()\n</code></pre>"},{"location":"reference/go/grid/#controller","title":"Controller","text":"<p>Will return the grid controller instance.</p> <pre><code>ctrl := scrope.Controller()\n</code></pre>"},{"location":"reference/go/grid/#render","title":"Render","text":"<p>Will render the grid by the actual grid mode.</p> Mode set in frontend data Description <code>grid.SrcCallback</code> <code>data</code> The source callback function is called. as first param the requested callback will be set as string. <code>grid.SrcCreate</code> The source create function is called. <code>grid.SrcUpdate</code> The source update function is called. <code>grid.SrcDelete</code> The condition first will be called to ensure the correct primary key. The source delete function is called. <code>grid.FeTable</code> <code>pagination</code>, <code>head</code>, <code>data</code>, <code>config</code> ConditionAll is called to create the condition. Add header/pagination if its not excluded by param. The source all function is called. Add config and result to the controller. call the defined render type. <code>grid.FeExport</code> <code>head</code>, <code>data</code>, <code>config</code> Same as FeTable but without the pagination and limit. <code>grid.FeCreate</code> <code>head</code> add header data. <code>grid.FeDetails</code>,<code>grid.FeUpdate</code> <code>head</code>, <code>data</code> add header data. call conditionFirst. fetch the entry by the given id and set the controller data. <code>grid.FeFilter</code> TODO <code>grid.FeHistory</code> <code>histories</code>, <code>users</code> all history entries and user data to the given sourceID will be fetched."},{"location":"reference/go/grid/#orm","title":"Orm","text":"<p>With the orm function an <code>orm.Interface</code> will be converted to a <code>grid.Source</code> and can be used out of the box.</p> <p>History is implemented.</p> <pre><code>g := grid.New(ctrl, grid.Orm(model), nil)\n</code></pre>"},{"location":"reference/go/grid/#history","title":"History","text":"<p>Info</p> <p>Must be implmented by the source.</p> <p>The data will be saved in the <code>histories</code> table by the <code>grid.Histroy</code> struct. The following Fields are available defined:</p> <p>grid.History saves the entries in the database with all the needed information.</p> Field value Description GridID <code>string</code> The grid id. There can be multiple IDs set. The will get separated through <code>,</code> UserID <code>string</code> The users id as a string. SrcID <code>string</code> The ID of the source struct. Type <code>enum</code> Can have the value <code>Created</code>, <code>Updated</code> or <code>Deleted</code> Value <code>text</code> <code>orm.ChangeValue</code> as json. CratedAt <code>datetime</code> The current datetime when it was created. <p>Info</p> <p>If the <code>UserID</code> is <code>0</code> or <code>grid.HistroySystemUser</code>, it will be displayed as a SYSTEM user. This can be used for cronjobs or other automated changes.</p> <p>orm.ChangeValue will be used to describe the source changes.</p> Field value Description Field <code>string</code> The name of the struct field. Operation <code>string</code> Value of <code>create</code>, <code>update</code> or <code>delete</code> New <code>string</code> The new value of the field. Can be empty if zero value. Old <code>string</code> The old value of the field. Can be empty if zero value. Index <code>int</code> Only used for <code>hasMany</code> relations. Children <code>[]orm.ChangeValue</code> Same fields as described before in a deeper level. <p>Create: Fields will only be added if they have no zero value.</p> Type Description normal field <code>New</code> will be the value of the field. belongsTo, m2m <code>New</code> field will be the value of the select <code>TextValue</code> field. To guarantee the correct value in the future, also if the ID got deleted. HasOne Every field will be in the <code>Childeren</code> slice if the value is not zero. HasMany Same as <code>hasOne</code> but a the <code>Index</code> field will be set. <p>Update Only changed values will be added.</p> Type Description normal field <code>New</code> and <code>Old</code> will have the fields value. If one of it has a zero value, it will be omitted. belongsTo, m2m <code>New</code> and <code>Old</code> will be the value of the select <code>TextValue</code> field. To guarantee the correct value in the future, also if the ID got deleted. If one of it has a zero value, it will be omitted. HasOne Every field will be in the <code>Childeren</code> slice if the value is not zero. HasMany Can have the following state <code>create</code>, <code>update</code> or <code>delete</code>. On <code>create</code> only the new value will be set, on <code>delete</code> only the old value. <p>Delete</p> <p>A <code>orm.History</code> entry will be added with the <code>Type: DELETED</code>.</p>"},{"location":"reference/go/grid/#manually-add-history","title":"manually add history","text":"<pre><code>err := grid.NewHistory(\"gridID\", \"userID\", \"srcID\", grid.HistoryCreated, \"New data received.\")\n//...\n</code></pre>"},{"location":"reference/go/grid/#source-interface","title":"Source interface","text":"<p>To create your own source, you have to implement the <code>grid.Source</code>.</p> <pre><code>type Source interface {\nCache() cache.Manager\n\nPreInit(Grid) error\nInit(Grid) error\nFields(Grid) ([]Field, error)\nUpdatedFields(Grid) error\n\nCallback(string, Grid) (interface{}, error)\nFirst(condition.Condition, Grid) (interface{}, error)\nAll(condition.Condition, Grid) (interface{}, error)\nCreate(Grid) (interface{}, error)\nUpdate(Grid) error\nDelete(condition.Condition, Grid) error\nCount(condition.Condition, Grid) (int, error)\n\n//Interface() interface{}\n}\n</code></pre>"},{"location":"reference/go/install/","title":"Install","text":"<pre><code>go get github.com/patrickascher/gofer\n</code></pre>"},{"location":"reference/go/logger/","title":"Logger","text":"<p>The package logger provides an interface for logging. It wraps awesome existing go loggers with that interface. In that case, it is easy to change the log provider without breaking anything in your application.</p> <p>Additionally log level, fields, time duration or caller information can be added.</p>"},{"location":"reference/go/logger/#register","title":"Register","text":"<p>To register a logger by your requirements, simple use the <code>logger.Register</code> function. The registered logger must implement the <code>logger.Provider</code> interface.</p> <p>This should be done in the <code>init()</code> function or any other early stage in your application.</p> <p>For a list of all existing provider see providers section.</p> <pre><code>// Example of the memory cache provider\nlogrus := logrus.New()\n// the wrapped logrus instance can be configured as needed.\nlogrus.Instance.ReportCaller = true\n\n// register the logger under a defined name\nerr = logrus.Register(\"importLogger\",logrus)\n//...\n</code></pre>"},{"location":"reference/go/logger/#usage","title":"Usage","text":"<p>Use <code>Get()</code> to get a registered logger instance.</p> <pre><code>// get the logger\nlog,err := logger.Get(\"importLogger\")\n\n// set some default logger settings.\nlog.SetCallerFields(true)\nlog.SetLogLevel(logger.TRACE)\n\n// creates a new info log entry.\nlog.Info(\"something\")\n\n// log with some details\nlog.WithFields(logger.Fields{\"foo\":\"bar\"}).Info(\"something\")\n\n// log with timer\nltimer := log.WithTimer()\n//.. some logic\nltimer.Debug(\"some time\") //Field \"duration\" is added with the required time.\n</code></pre>"},{"location":"reference/go/logger/#setcallerfields","title":"SetCallerFields","text":"<p>If you call <code>SetCallerFields</code> on a logger instance, it will add the file name and line number as fields. Default it is set to <code>false</code>. The caller will be set global for this logger instance.</p> <pre><code>log.SetCallerFields(true)\n</code></pre>"},{"location":"reference/go/logger/#setloglevel","title":"SetLogLevel","text":"<p>Defines the level where it should start logging. Available log levels are <code>logger.TRACE</code>,<code>logger.DEBUG</code>,<code>logger.INFO</code> ,<code>logger.WARNING</code>,<code>logger.ERROR</code> and <code>logger.PANIC</code>. Default it is set to <code>logger.DEBUG</code>. The level will be set global for this logger instance.</p> <pre><code>log.SetLogLevel(logger.INFO)\n</code></pre>"},{"location":"reference/go/logger/#log-level","title":"Log Level","text":"<p>The following log levels are available.</p> <pre><code>log.Trace(\"msg\")\nlog.Debug(\"msg\")\nlog.Info(\"msg\")\nlog.Warning(\"msg\")\nlog.Error(\"msg\")\nlog.Panic(\"msg\")\n</code></pre>"},{"location":"reference/go/logger/#withfields","title":"WithFields","text":"<p>Sometimes a log message is not enough and some additional information is required.</p> <p>Info</p> <p><code>WithFields</code> will create a new instance.</p> <pre><code>log.WithFields(logger.Fields{\"foo\":\"bar\"}).Info(\"msg\")\n</code></pre>"},{"location":"reference/go/logger/#withtimer","title":"WithTimer","text":"<p>Sometimes it is useful for debugging to see the required time of a function. <code>WithTimer</code> can be combined <code>WithFields</code> or vis-a-vis.</p> <p>Info</p> <p><code>WithTimer</code> will create a new instance.</p> <pre><code>ltimer := log.WithTimer()\n//...\nltimer.Debug(\"msg\") // a Field \"duration\" with the required time is added.\n\n// combinde with fields\nltimer = log.WithFields(logger.Fields(\"foo\":\"bar\")).WithTimer()\n//...\nltimer.Debug(\"msg\")// a Field \"duration\" and \"foo\" is added.\n</code></pre>"},{"location":"reference/go/logger/#new","title":"New","text":"<p>Sometimes its useful to create a logger with slightly a different configuration. The new instance will inherit the setting of the parent logger by default.</p> <pre><code>log,err := logger.Get(\"importLogger\")\nlog.SetCallerFields(true)\nlog.SetLogLevel(logger.WARNING)\n\n// create a new instance and add different settings.\nlog2 := log.New()\nlog2.SetCallFields(false)\nlog2.SetLogLevel(logger.TRACE)\n</code></pre>"},{"location":"reference/go/logger/#providers","title":"Providers","text":"<p>All pre-defined providers:</p>"},{"location":"reference/go/logger/#logrus","title":"Logrus","text":"<p>A wrapper for logrus.</p> <p>Package:</p> <p><code>github.com/patrickascher/gofer/logger/logrus</code></p> <p>Options:</p> <p>The original logrus struct can be accessed by the <code>Instance</code> field. Please check the github page for the documentation.</p> <p>Usage:</p> <pre><code>import \"github.com/patrickascher/gofer/logger\"\nimport \"github.com/patrickascher/gofer/logger/logrus\"\n\nlogrusProvider := logrus.New()\nlogrusProvider.Instance.ReportCaller = true\n\n// register the logger\nerr := logger.Register(\"logger-name\", logrusProvider)\n\n// somewhere in the application\nlog,err := logger.Get(\"logger-name\")\n</code></pre>"},{"location":"reference/go/logger/#create-your-own-provider","title":"Create your own provider","text":"<p>To create your own provider, you have to implement the <code>logger.Provider</code> interface.</p> <pre><code>type Provider interface {\n    Log(Entry)\n}\n</code></pre> <p>The registered value must be of the type <code>logger.Provider</code>.</p> <pre><code>type MyLogger struct{\n}\n\nfunc (ml *MyLogger) Log(Entry){\n    // ... do something\n}\n\n// register the logger\nerr := logger.Register(\"my-logger\", &amp;MyLogger{})\n\n// somewhere in the application\nlog,err := logger.Get(\"my-logger\")\n</code></pre>"},{"location":"reference/go/logger/#entry","title":"Entry","text":"<p>The <code>logger.Entry</code> holds all information about the log message.</p> <pre><code>type Entry struct {\n    Level     level\n    Timestamp time.Time\n    Message   string\n    Fields    Fields\n}\n</code></pre>"},{"location":"reference/go/orm/","title":"Orm","text":"<p>Package orm transfers a struct into an ORM by simple embedding the <code>orm.Model</code>. Relations <code>hasOne</code>, <code>belongsTo</code> , <code>hasMany</code> and <code>m2m</code> will be defined automatically / manually.</p>"},{"location":"reference/go/orm/#usage","title":"Usage","text":"<pre><code>type User struct{\norm.Model\n\nID      int\nName    string\nSurname string\n}\n\nuser := User{}\n\n// initialize orm model\nerr = user.Init(&amp;user)\nif err!=nil{\n//...\n}\n\n// scope for some helper - if needed\nscope, err := user.Scope()\nif err!=nil{\n//...\n}\n\n// set data\nuser.Name = \"John\"\nuser.Surname = \"Doe\"\n\n// create entry\nerr = user.Create()\n//..\n</code></pre> <p>Requirements / defaults:</p> <ul> <li>Database name, Table name, Builder and Cache must be set. [see Default]</li> <li>Model requires one or more primary keys. If the field <code>ID</code> exists, it will automatically be taken as primary key.   Primary keys can be set manually via Tags. [see Tags]</li> <li>All fields and relations must be available on the database backend, or they must be defined as custom.</li> <li>Unique field names must be provided. If an embedded struct overwrites a field name or relation, an error will return.</li> <li>Fields are allowed with the following type <code>string</code>, <code>bool</code> <code>uint</code> <code>int</code> <code>float</code> and any type which implements   the <code>sql.Scanner</code> and <code>driver.Valuer</code> interface.</li> <li>Relations are only set if they implement the <code>orm.Interface</code>, except it's defined as custom.</li> </ul>"},{"location":"reference/go/orm/#first","title":"First","text":"<p>Will return the first found row.</p> <p>Error <code>sql.ErrNoRows</code> will return if no result was found.</p> <pre><code>user := User{}\nerr := user.Init(&amp;orm)\n// ...\n\n// first without any condition\nerr = user.First()\n\n// first with a condition (id=1\nerr = user.First(condition.New().SetWhere(\"id = ?\", 1))\n</code></pre>"},{"location":"reference/go/orm/#all","title":"All","text":"<p>Will return all rows by the given condition. For more details about the relation handling, see Strategy.</p> <p>No error will return if no result was found (TODO CHANGE? same logic as First?)</p> <pre><code>user := User{}\nerr := user.Init(&amp;orm)\n// ...\n\n// all without any condition\nvar users []User\nerr = user.All(&amp;user)\n\n// all with a condition (id&gt;10)\nerr = user.All(&amp;user, condition.New().SetWhere(\"id &gt; ?\", 10))\n</code></pre>"},{"location":"reference/go/orm/#count","title":"Count","text":"<p>Count the existing rows by the given condition.</p> <pre><code>user := User{}\nerr := user.Init(&amp;orm)\n// ...\n\n// count without any condition\nrows, err = user.Count()\n\n// count with a condition (id&gt;10)\nrows, err = user.Count(condition.New().SetWhere(\"id &gt; ?\", 10))\n</code></pre>"},{"location":"reference/go/orm/#create","title":"Create","text":"<p>Will create an entry. For more details about the relation handling, see Strategy.</p> <pre><code>user := User{}\nerr := user.Init(&amp;orm)\n// ...\n\nuser.Name = \"John\"\nuser.Surname = \"Doe\"\nuser.Phonenumbers = append(user.Phonenumbers, \"000-111-222\") //has m\n\nerr = user.Create()\n</code></pre>"},{"location":"reference/go/orm/#update","title":"Update","text":"<p>Will update an entry. For more details about the relation handling, see Strategy.</p> <p>A Snapshot will be taken and only changed values will be updated.</p> <pre><code>user := User{}\nerr := user.Init(&amp;orm)\n// ...\n\nuser.Name = \"Foo\"\nuser.Surname = \"Bar\"\n\nerr = user.Update()\n</code></pre>"},{"location":"reference/go/orm/#delete","title":"Delete","text":"<p>Will delete an entry. For more details about the relation handling, see Strategy.</p> <pre><code>user := User{}\nerr := user.Init(&amp;orm)\n// ...\nuser.ID = 4\nerr = user.Delete()\n</code></pre>"},{"location":"reference/go/orm/#permissions","title":"Permissions","text":"<p>Like the permission tag see Tags, it's sometimes useful to dynamic set the policy and fields.</p> <p><code>Permissions</code> sets the read/write permission for the given fields. This means you can allow or disallow single fields for saving / fetching. The field setting will overwrite the configured permission tag.</p> <p>Info</p> <p>Primary-, foreign-, reference and polykeys are always added. This means if an ID, which is a primary key gets blacklisted, the ID field will be removed from the blacklist automatically.</p> <pre><code>// set field permission - only Name, Surname and all mandatory keys will be loaded.\nuser.SetPermissions(orm.WHITELIST, \"Name\", \"Surname\")\n\n// read the configured permissions\npolicy, fields := user.Permissions()\n</code></pre>"},{"location":"reference/go/orm/#tags","title":"Tags","text":"<p>The orm struct fields can be simple configured by tags. The tag must be defined under the key <code>orm</code></p> <p>For more details about the tags, see ParseTag</p> Tag Description Values Example <code>-</code> Skips the complete struct field. <code>orm:\"-\"</code> custom Defines a field as a none sql field. <code>orm:\"custom\"</code> column Set a custom table column name name <code>orm:\"column:name\"</code> permission A field can be defined as Write or Read only. If the permission is empty read and write will be set to <code>false</code>. If a read permission is false, it the column will not be fetched by first and all. If a write permission is false, the column will not be saved on create or update. r,w or empty. <code>orm:\"permission:rw\"</code> sql Set a custom select for the column. Only supported for <code>First</code> and <code>All</code>. Will be set as DbExpr to avoid escaping problems. Be aware you have to escape on your own. string <code>orm:\"sql:CONCAT(name,surname)\"</code> primary Defines a column as primary. <code>orm:\"primary\"</code> relation Defines a relation <code>hasOne</code>, <code>belongsTo</code>, <code>hasMany</code>, <code>m2m</code> <code>orm:\"relation:belongsTo\"</code> fk Defines a custom foreign key string <code>orm:\"fk:CustomID\"</code> refs Defines a custom references key. string <code>orm:\"refs:UserID\"</code> join_table Defines a custom  join table name. string <code>orm:\"join_table:user_mapping\"</code> join_fk Defines a custom foreign column name for the junction table. string <code>orm:\"join_fk:CustomID\"</code> join_refs Defines a custom references column name for the junction table. string <code>orm:\"join_refs:UserID\"</code> poly Defines a custom poly name. string <code>orm:\"poly:Toy\"</code> poly_value Defines a custom poly value. string <code>orm:\"poly:User\"</code>"},{"location":"reference/go/orm/#validation","title":"Validation","text":"<p>Validation for struct fields can be configured by tags.</p> <p>Under the hood the package validator is used. Struct fields validation can be defined by the tag <code>validate</code>. Please check out the validator documentation for all available tags.</p> <p>All query.NullTypes are registered and can be validated.</p> <p>Custom validation <code>tags</code> can be registered by <code>orm.RegisterValidation(tag string, fn func(ctx context.Context, fl valid.FieldLevel) bool, callValidationEvenIfZero ...bool)</code> . As context the <code>orm.Interface</code> will be set under the name <code>orm.MODEL</code>.</p> <p>Info</p> <p>The validation happens on <code>orm.Create</code> and <code>orm.Update</code>. Only on struct fields with write permission.</p> <pre><code>type User struct{\norm.Model\n\nName `validate:\"required\"`\nCountry `validate:\"country\"`\n}\n\nerr := orm.RegisterValidation(\"country\", countryValidation)\nif err != nil{\n// ...\n}\n\nfunc countryValidation(ctx ctx.Context, fl valid.FieldLevel) bool {\nmodel := ctx.Value(orm.MODEL).(orm.Interface)\n// ... some checks\nreturn true\n}\n</code></pre>"},{"location":"reference/go/orm/#defaults","title":"Defaults","text":""},{"location":"reference/go/orm/#struct-defaults","title":"Struct defaults","text":"<p>The orm can be simple customized by struct functions.</p> <pre><code>func (u User) DefaultTableName(){\nreturn \"users\"\n}\n</code></pre> Function Description Default Return Value DefaultCache A <code>cache.Manager</code> and <code>time.Duration</code> must be set. The <code>time.Duration</code> indicates how log the <code>orm.Model</code> should be cached. [see Cache] - <code>cache.Manager</code>, <code>time.Duration</code> DefaultBuilder A <code>query.Builder</code> must be set for the sql handling. [see Query] - <code>query.Builder</code> DefaultTableName The struct table name. Plural name of the struct in snake_case. <code>string</code> DefaultDatabaseName The struct database name. The <code>query.Builder.Config().Database</code> value. <code>string</code> DefaultStrategy The data fetching strategy. [see Strategy] eager <code>string</code> DefaultSoftDelete Soft deletion instead of deleting the complete db entry.  [see SoftDelete] <code>DeletedAt</code> <code>orm.SoftDelete</code>"},{"location":"reference/go/orm/#softdelete","title":"SoftDelete","text":"<p>By default, a db row will not get deleted, when a column <code>deleted_at</code> is available. The default value will be the actual timestamp.</p> <p>To change this behaviour, simple overwrite the <code>DefaultSoftDelete</code> function. In the example the db field <code>status</code> will be set with the value <code>1</code> and all rows with the value <code>0</code> are active.</p> <pre><code>func (y YourModel) DefaultSoftDelete() SoftDelete {\nSoftDelete{Field: \"Status\", Value: \"1\", ActiveValues: []interface{}{\"0\"}}\n}\n</code></pre> <p>Info</p> <p>If the soft delete field does not exist in the struct, an error will return on <code>orm.Init()</code>.</p>"},{"location":"reference/go/orm/#relations","title":"Relations","text":"<p>Warn</p> <p>Everything in Relations will be developer information and you can probably skip it.</p> <p>Info</p> <p>All default settings can be overwritten by tag.</p> <p>By default, relations will be defined by the struct type.</p> <ul> <li>struct will be by default a <code>hasOne</code> relation.</li> <li>slice will be by default a <code>hasMany</code> relation.</li> <li>slice self referencing will be by default a <code>m2m</code> relation</li> </ul>"},{"location":"reference/go/orm/#hasone-hasmany","title":"HasOne, HasMany","text":"<p><code>fk</code> The foreign key will be the primary key of the orm model.</p> <p><code>refs</code> The references will be the orm model name + ID on the relation model.</p> <p><code>poly</code> The polymorphic is by default the relation orm name + ID (will be set as Refs) and name + Type. The value will be the orm model name.</p> <pre><code>user User{\nID int\nAdr Address{\nID      int\nUserID  int\nStreet  string\n}\n}\n// fk   = ID\n// refs = UserID or AddressID if poly is set.\n// poly = Address\n// poly_value = User\n</code></pre>"},{"location":"reference/go/orm/#belongsto","title":"BelongsTo","text":"<p><code>fk</code> The foreign key will be the relation orm model name + ID on the orm model.</p> <p><code>refs</code> The relation orm model's primary key.</p> <p><code>poly</code> The polymorphic is by default the relation orm name + ID (will be set as FK) and name + Type. The value will be the orm model name.</p> <pre><code>user User{\nID int\nAddressID\nAdr Address{\nID      int\nUserID  int\nStreet  string\n}\n}\n// fk   = AddressID\n// refs = ID or AddressID if poly is set.\n// poly = Address\n// poly_value = User\n</code></pre>"},{"location":"reference/go/orm/#manytomany","title":"ManyToMany","text":"<p><code>fk</code> The foreign key will be the primary key of the orm model.</p> <p><code>refs</code> The references will be the primary key of the orm relation model.</p> <p><code>poly</code> The polymorphic is by default the relation orm name + ID (will be set as Refs) and name + Type. The value will be the orm model name.</p> <p><code>join_table</code> The orm model name + orm relation name in snake style and plural.</p> <p><code>join_fk</code> The foreign key will be the orm model name + ID of the orm model.</p> <p><code>join_refs</code> The references key will be the orm relation model name + ID of the orm relation model. It will be <code>child_id</code> on self referencing.</p> <pre><code>user User{\nID int\nAddressID\nAdr []Address{\nID      int\nUserID  int\nStreet  string\n}\n}\n// fk   = ID\n// refs = ID \n// poly = Address\n// poly_value = User\n// join_table = user_addresses\n// join_fk = user_id\n// join_refs = address_id , child_id - on self referencing\n</code></pre>"},{"location":"reference/go/orm/#scope","title":"Scope","text":"<p>The scope includes some helper functions for the orm model.</p> <p>Error will return if the orm model was not initialized yet.</p> <pre><code>// ...\nscope,err := model.Scope()\nif err!=nil{\n    // ...\n}\n</code></pre>"},{"location":"reference/go/orm/#setconfig","title":"SetConfig","text":"<p>Can be used to customize the relation or root orm model configuration. If no name is given, the scopes root will be set.</p> <pre><code>// customizing a relation sql condition\nconfig := scope.SetConfig(orm.NewConfig().SetCondition(condition.New().SetWhere(\"id&gt;?\",10),true),\"Address\")\n</code></pre> Field Default Description SetAllowHasOneZero <code>true</code> will trigger an error if a <code>hasOne</code> relation has no rows and its set to false. SetShowDeletedRows <code>false</code> will show/hide the deleted rows by the soft delete definitions. SetUpdateReferenceOnly <code>false</code> will only update the reference on <code>belongsTo</code> and <code>m2m</code> relations instead of updating the relation model. SetCondition add a sql condition. the condition can be merged with the defaults or replace them. Condition will return the defined condition"},{"location":"reference/go/orm/#config","title":"Config","text":"<p>Will return the defined orm model configuration. If no name is given, the scopes root configuration will be taken.</p> <pre><code>config := scope.Config()\n</code></pre>"},{"location":"reference/go/orm/#name","title":"Name","text":"<p>Will return the name of the struct, with or without the package prefix.</p> <pre><code>// with package name\nname := scope.Name(true)\n\n// without package name\nname = scope.Name(true)\n</code></pre>"},{"location":"reference/go/orm/#builder","title":"Builder","text":"<p>Builder will return the model builder.</p> <pre><code>builder := scope.Builder()\n</code></pre>"},{"location":"reference/go/orm/#fqdntable","title":"FqdnTable","text":"<p>Is a helper to display the models database and table name.</p> <pre><code>table := scope.FqdnTable()\n</code></pre>"},{"location":"reference/go/orm/#fqdnmodel","title":"FqdnModel","text":"<p>Is a helper to display the model name and the field name.</p> <pre><code>field := scope.FqdnModel(\"Name\")\n// field: orm.User:Name\n</code></pre>"},{"location":"reference/go/orm/#model","title":"Model","text":"<p>Will return the scopes orm model.</p> <pre><code>model := scope.Model()\n</code></pre>"},{"location":"reference/go/orm/#caller","title":"Caller","text":"<p>Will return the orm model caller.</p> <pre><code>caller := scope.Caller()\n</code></pre>"},{"location":"reference/go/orm/#cache-setcache","title":"Cache, SetCache","text":"<p>Set or get the model cache. At the moment not in use because of the DefaultCache logic. TODO: Delete?</p>"},{"location":"reference/go/orm/#sqlfields","title":"SQLFields","text":"<p>Will return all struct fields by permission as slice string.</p> <pre><code>fields := scope.SQLFields(Permission{Read:true})\n</code></pre>"},{"location":"reference/go/orm/#sqlscanfields","title":"SQLScanFields","text":"<p>SQLScanFields is a helper for row.scan. It will scan the struct fields by the given permission.</p> <pre><code>fields := scope.SQLScanFields(Permission{Read:true})\n</code></pre>"},{"location":"reference/go/orm/#sqlcolumns","title":"SQLColumns","text":"<p>Will return all struct fields by permission as slice string.</p> <pre><code>cols := scope.SQLColumns(Permission{Read:true})\n</code></pre>"},{"location":"reference/go/orm/#field","title":"Field","text":"<p>Returns a ptr to the struct field by name. Error will return if the field does not exist.</p> <pre><code>field,err := scope.Field(\"Name\")\n</code></pre>"},{"location":"reference/go/orm/#fieldvalue","title":"FieldValue","text":"<p>Returns a reflect.Value of the orm caller struct field. It returns the zero Value if no field was found.</p> <pre><code>rv := scope.FieldValue(\"Name\")\n</code></pre>"},{"location":"reference/go/orm/#sqlrelation","title":"SQLRelation","text":"<p>Will return teh requested relation by permission. Relations(s) which are defined as \"custom\" or have not the required Permission will not be returned. Error will return if the relation does not exist or has not the required permission.</p> <pre><code>relation,err := scope.SQLRelation(\"Address\",Permission{Read:true})\n</code></pre>"},{"location":"reference/go/orm/#sqlrelations","title":"SQLRelations","text":"<p>SQLRelations will return all sql relations by the given Permission. Relation(s) which are defined as \"custom\" or have not the required Permission will not be returned.</p> <pre><code>relations := scope.SQLRelations(Permission{Read:true})\n</code></pre>"},{"location":"reference/go/orm/#primarykeysset","title":"PrimaryKeysSet","text":"<p>Checks if all primaries have a non zero value.</p> <pre><code>valid := scope.PrimaryKeysSet()\n</code></pre>"},{"location":"reference/go/orm/#primarykeys","title":"PrimaryKeys","text":"<p>Will return all defined primary keys of the struct. Error will return if none was defined.</p> <pre><code>primaryFields,err := scope.PrimaryKeys()\nif err!=nil{\n  // ...\n}\n</code></pre>"},{"location":"reference/go/orm/#softdelete_1","title":"SoftDelete","text":"<p>Will return the soft deleting struct.</p> <pre><code>sd := scope.SoftDelete()\n</code></pre>"},{"location":"reference/go/orm/#parent","title":"Parent","text":"<p>Parent returns the parent model by name or the root model if the name is empty. The name must be the orm struct name incl. namespace. Error will return if no parent exists or the given name does not exist. The max search depth is limited to 20.</p> <pre><code>model,err := scope.Parent(\"User\")\n</code></pre>"},{"location":"reference/go/orm/#setparent","title":"SetParent","text":"<pre><code>scope.SetParent(model)\n</code></pre>"},{"location":"reference/go/orm/#isempty","title":"IsEmpty","text":"<p>Checks if all the orm model fields and relations are empty.</p> <pre><code>valid := scope.IsEmpty(Permission{Read:true})\n</code></pre>"},{"location":"reference/go/orm/#isselfreferenceloop","title":"IsSelfReferenceLoop","text":"<p>IsSelfReferenceLoop checks if the model has a self reference loop.</p> <p>Animal (hasOne) -&gt; Address (belongsTo) -&gt; *Animal</p> <pre><code>valid := scope.IsSelfReferenceLoop(relation)\n</code></pre>"},{"location":"reference/go/orm/#isselfreferencing","title":"IsSelfReferencing","text":"<p>IsSelfReferencing is a helper to check if the model caller has the same type as the given field type.</p> <p>Role.Roles (m2m) -&gt; Role</p> <pre><code>valid := scope.IsSelfReferenceLoop(relation)\n</code></pre>"},{"location":"reference/go/orm/#takesnapshot","title":"TakeSnapshot","text":"<p>TakeSnapshot will define if a snapshot of the orm model will be taken. This is used mainly in update.</p>"},{"location":"reference/go/orm/#appendchangedvalue","title":"AppendChangedValue","text":"<p>AppendChangedValue adds the changedValue if it does not exist yet by the given field name.</p>"},{"location":"reference/go/orm/#setchangedvalues","title":"SetChangedValues","text":"<p>SetChangedValues sets the changedValues field of the scope. This is used to pass the values to a child orm model.</p>"},{"location":"reference/go/orm/#changedvaluebyfieldname","title":"ChangedValueByFieldName","text":"<p>ChangedValueByFieldName returns a *changedValue by the field name. Nil will return if it does not exist.</p>"},{"location":"reference/go/orm/#initrelationbyfield","title":"InitRelationByField","text":"<p>InitRelationByField will return the orm.Interface of the field.</p> <p>ptr * = if the value was nil, a new orm.Interface gets set, if its not nil, the value will be taken.</p> <p>struct = * of that struct</p> <p>ptr *[], [] = new orm.Interface</p>"},{"location":"reference/go/orm/#initrelation","title":"InitRelation","text":"<p>InitRelation initialize the given relation. The orm model parent will be set, config, permission list and tx will be passed.</p>"},{"location":"reference/go/orm/#setbackreference","title":"SetBackReference","text":"<p>SetBackReference will set a backreference if detected.</p>"},{"location":"reference/go/orm/#newscopefromtype","title":"NewScopeFromType","text":"<p>Will return a new scope of the given type.</p>"},{"location":"reference/go/orm/#strategy","title":"Strategy","text":"<p>Every orm model can have its own loading strategy. By default <code>eager</code> is defined.</p>"},{"location":"reference/go/orm/#eager","title":"Eager","text":"<p>The eager loading strategy will load the root orm and all relations at once.</p> <p>It is possible to only load required data by setting the field/relation permissions.  see Permissions.</p> <p>The following will describe the internal logic of the eager strategy. This information is only interesting for the framework contributors.</p>"},{"location":"reference/go/orm/#first_1","title":"First","text":"<p>First will return one row by the given condition. If a soft delete field is defined, by default only the \"not soft deleted\" rows will be shown. This can be changed by config. If a HasOne relation returns no result, an error will return. This can be changed by config. Only fields with the read permission will be read. Error (sql.ErrNoRows) returns if First finds no rows.</p> <p>HasOne, BelongsTo: will call orm First().</p> <p>HasMany, ManyToMany will call orm All().</p>"},{"location":"reference/go/orm/#all_1","title":"All","text":"<p>All rows by the given condition will be fetched. All foreign keys are collected after the main select, all relations are handled by one request to minimize the db queries. m2m has actual 3 selects to ensure a different db builder could be used. The data is mapped automatically afterwards. Only fields with the read permission will be read.</p> <p>*** TODO***  Back-Reference only works for First -&gt; All calls at the moment.</p>"},{"location":"reference/go/orm/#create_1","title":"Create","text":"<p>Create a new entry.</p> <p>BelongsTo: will be skipped on empty or if a self reference loop is detected. Otherwise the entry will be created and the reference field will be set. If the belongsTo primary key(s) are already set, it will update the entry instead of creating it (if the pkey exists in the db). There is an option to only update the reference field without creating or updating the linked entry. (belongsTo, manyToMany) Only fields with the write permission will be written.</p> <p>Field(s): will be created and the last inserted ID will be set to the model.</p> <p>HasOne:</p> <p>If the value is zero it will be skipped.</p> <p>The reference keys (fk and poly) will be set to the child orm and will be created.</p> <p>HasMany:</p> <p>If the value is zero it will be skipped.</p> <p>If the relations has no sub relations, a batch insert is made to limit the db queries.</p> <p>If relations exists, a normal Create will happen.</p> <p>In both cases, the reference keys (fk and poly) will be set to the child orm and will be created.</p> <p>ManyToMany:</p> <p>If the value is zero it will be skipped.</p> <p>If the primary key(s) are already set, it will update the entry instead of creating it (if the pkey exists in the db).</p> <p>The junction table will be filled automatically.</p> <p>There is an option to only update the reference field without creating or updating the linked entry.</p>"},{"location":"reference/go/orm/#update_1","title":"Update","text":"<p>Update entry by the given condition. Only fields with the wrote permission will be written. There is an option to only update the reference field without creating or updating the linked entry. (BelongsTo, ManyToMany) Only changed values will be updated. A Snapshot over the whole orm is taken before.</p> <p>BelongsTo :</p> <ul> <li>CREATE: create or update (pk exist) the orm model.</li> <li>UPDATE: Update the parent orm model.</li> <li>DELETE: Only the reference is deleted at the moment.</li> </ul> <p>Field(s): gets updated if the value changed.</p> <p>HasOne:</p> <ul> <li>CREATE: set reference IDs to the child orm, delete old references (can happen if a user add manually a struct), create   the new entry.</li> <li>UPDATE: set reference IDs to the child orm, update the child orm.</li> <li>DELETE: delete the child orm. (query deletion happens - performance, TODO: call orm.Delete() to ensure soft delete?)</li> </ul> <p>HasMany:</p> <ul> <li>CREATE: create the entries.</li> <li>UPDATE: the changed value entry is defined in the following categories.<pre><code>- CREATE: slice entries gets created.\n- UPDATE: slice entries gets updates.\n- DELETE: all IDs gets collected and will be deleted as batch to minimize the db queries.\n</code></pre> <ul> <li>DELETE: entries will get deleted by query.(query deletion happens - performance, TODO: call orm.Delete() to ensure   soft delete?</li> </ul> </li> </ul> <p>ManyToMany:</p> <ul> <li>CREATE: Create or update (if pk is set and exists in db) the slice entry. the junction table will be batched to   minimize the db queries.</li> <li>UPDATE: the changed value entry is defined in the following categories.<pre><code>- CREATE: slice entries gets created or updated (if pk is set and exists in db). the junction table will be batched.\n- UPDATE: the slice entry.\n- DELETE: collect all deleted entries. delete only in the junction table at the moment. the junction table will be batched. TODO: think about a strategy.\n</code></pre> <ul> <li>DELETE: entries are only deleted by the junction table at the moment. TODO: think about a strategy.</li> </ul> </li> </ul>"},{"location":"reference/go/orm/#create-your-own","title":"Create your own","text":"<p>To create your own strategy, you have to implement the <code>Strategy</code> interface.</p> <pre><code>type Strategy interface {\nFirst(scope Scope, c condition.Condition, permission Permission) error\nAll(res interface{}, scope Scope, c condition.Condition) error\nCreate(scope Scope) error\nUpdate(scope Scope, c condition.Condition) error\nDelete(scope Scope, c condition.Condition) error\nLoad(interface{}) Strategy\n}\n</code></pre> <p>Use the <code>init</code> function to register your strategy by name</p> <p>The registered value must be of the type <code>func(Strategy, error)</code>.</p> <pre><code>func init() {\nerr := Register(\"yourStrategy\", newStrategy)\nif err != nil {\nlog.Fatal(err)\n}\n}\n\n// newEager returns the orm.Strategy.\nfunc newStrategy() (Strategy, error) {\nreturn &amp;something{}, nil\n}\n</code></pre> <p>Now you can can access the strategy from your orm model by defining the <code>DefaultStrategy</code> function with the required strategy.</p>"},{"location":"reference/go/query/","title":"Query","text":"<p>The package query provides a simple programmatically sql query builder. The idea was to create a unique query builder which can be used with any database driver in go - with minimal effort.</p> <p>Features:</p> <ul> <li>Unique Placeholder for all database drivers</li> <li>Batching function for large Inserts</li> <li>Whitelist</li> <li>automatic quote of column and table names.</li> <li>SQL queries and durations log debugging</li> </ul>"},{"location":"reference/go/query/#usage","title":"Usage","text":"<p>Inspired by the <code>database/sql</code>, this module is also based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section.</p> <pre><code>import \"github.com/patrickascher/gofer/query\"\nimport _ \"github.com/patrickascher/gofer/query/mysql\"\n</code></pre>"},{"location":"reference/go/query/#new","title":"New","text":"<p>To create a builder instance, you have to call <code>New()</code> with the needed provider name and configuration. Please see the providers section for a full list.</p> <pre><code>builder, err := query.New(\"mysql\", query.Config{})\n</code></pre>"},{"location":"reference/go/query/#setlogger","title":"SetLogger","text":"<p>A <code>logger.Manager</code> logger can be added to the builder. If one is defined, all queries will be logged on <code>DEBUG</code> level.</p> <pre><code>builder.SetLogger(logManager)\n</code></pre>"},{"location":"reference/go/query/#config","title":"Config","text":"<p>Will return the <code>query.Config</code>.</p> <pre><code>builder.Config()\n</code></pre>"},{"location":"reference/go/query/#quoteidentifier","title":"QuoteIdentifier","text":"<p>Will quote an identifier by the providers quote tags.</p> <pre><code>name := builder.QuoteIdentifier(\"test\")\n// on mysql name will be `test`\n</code></pre>"},{"location":"reference/go/query/#null-types","title":"Null types","text":"<p>The following null type are defined for dealing with nullable SQL and JSON values.</p> <p>Following helper functions are defined <code>NewNullString(string,valid)</code>, <code>NewNullBool(bool,valid)</code> ,<code>NewNullInt(int64,valid)</code>,<code>NewNullFloat(float64,valid)</code> and <code>NewNullTime(time.Time,valid)</code>.</p> <p>Info</p> <p>It' s a type alias for https://pkg.go.dev/github.com/guregu/null</p> <ul> <li>query.NullString</li> <li>query.NullBool</li> <li>query.NullInt</li> <li>query.NullFloat</li> <li>query.NullTime</li> </ul>"},{"location":"reference/go/query/#sanitizevalue","title":"SanitizeValue","text":"<p>SanitizeValue is a helper which converts:</p> <ul> <li><code>int</code>,<code>int8</code>,<code>int16</code>,<code>int32</code>,<code>int64</code>,<code>uint</code>,<code>uint8</code>,<code>uint16</code>,<code>uint32</code>,<code>uint64</code>,<code>query.NullInt</code> to <code>int64</code></li> <li><code>string</code>,<code>query.NullString</code> to <code>string</code></li> </ul> <p>Error will return if the argument is not of the described types, or a NullType is not valid.</p> <pre><code>value,err := query.SanitizeValue(1) \n// value will be int64(1) and err will be nil\n</code></pre>"},{"location":"reference/go/query/#query_1","title":"Query","text":"<p>To create any query you have to call the query function</p> <pre><code>builder.Query()\n</code></pre>"},{"location":"reference/go/query/#select","title":"Select","text":""},{"location":"reference/go/query/#columns","title":"Columns","text":"<p>Columns define a fixed column order for the insert. If the columns are not set manually, <code>*</code> will be used. Only Values will be inserted which are defined here. This means, you can use Columns as a whitelist.</p> <pre><code>b.Query().Select(\"test\").Column(\"name\", \"surname\")\n</code></pre>"},{"location":"reference/go/query/#condition","title":"Condition","text":"<p>Condition adds your own condition to the query.</p> <pre><code>c := condition.New().SetWhere(\"id = ?\", 1)\nb.Query().Select(\"test\").Condition(c)\n</code></pre>"},{"location":"reference/go/query/#join","title":"Join","text":"<p>Join wraps the <code>condition.SetJoin()</code> function. For more details see condition section.</p> <pre><code>b.Query().Select(\"test\").Join(condition.LEFT, \"test_relation\", \"test.id = test_relation\")\n</code></pre>"},{"location":"reference/go/query/#where","title":"Where","text":"<p>Where wraps the <code>condition.SetWhere()</code> function. For more details see condition section.</p> <pre><code>b.Query().Select(\"test\").Where(\"id = ?\", 1)\n</code></pre>"},{"location":"reference/go/query/#group","title":"Group","text":"<p>Group wraps the <code>condition.SetGroup()</code> function. For more details see condition section.</p> <pre><code>b.Query().Select(\"test\").Group(\"name\", \"surname\")\n</code></pre>"},{"location":"reference/go/query/#having","title":"Having","text":"<p>Having wraps the <code>condition.SetHaving()</code> function. For more details see condition section.</p> <pre><code>b.Query().Select(\"test\").Having(\"id = ?\", 1)\n</code></pre>"},{"location":"reference/go/query/#order","title":"Order","text":"<p>Order wraps the <code>condition.SetOrder()</code> function. For more details see condition section.</p> <pre><code>b.Query().Select(\"test\").Order(\"name\", \"-surname\")\n</code></pre>"},{"location":"reference/go/query/#limit","title":"Limit","text":"<p>Limit wraps the <code>condition.SetLimit()</code> function. For more details see condition section.</p> <pre><code>b.Query().Select(\"test\").Limit(10)\n</code></pre>"},{"location":"reference/go/query/#offset","title":"Offset","text":"<p>Offset wraps the <code>condition.SetOffset()</code> function. For more details see condition section.</p> <pre><code>b.Query().Select(\"test\").Offset(20)\n</code></pre>"},{"location":"reference/go/query/#string","title":"String","text":"<p>String returns the rendered statement and arguments.</p> <pre><code>sql, args, err := b.Query().Select(\"test\").String()\n</code></pre>"},{"location":"reference/go/query/#first","title":"First","text":"<p>First will return a sql.Row.</p> <pre><code>row, err := b.Query().Select(\"test\").Column(\"name\", \"surname\").First()\n// SELECT `name`, `surname` FROM test\n</code></pre>"},{"location":"reference/go/query/#all","title":"All","text":"<p>All will return sql.Rows.</p> <pre><code>res, err := b.Query().Select(\"test\").Column(\"name\", \"surname\").All()\n// SELECT `name`, `surname` FROM test\n</code></pre>"},{"location":"reference/go/query/#insert","title":"Insert","text":""},{"location":"reference/go/query/#batch","title":"Batch","text":"<p>Batch sets the batching size. Default batching size is 50.</p> <pre><code>b.Query().Insert(\"test\").Batch(20)\n</code></pre>"},{"location":"reference/go/query/#columns_1","title":"Columns","text":"<p>Columns define a fixed column order for the insert. If the columns are not set manually, all keys of the Values will be added. Only Values will be inserted which are defined here. This means, you can use Columns as a whitelist.</p> <pre><code>b.Query().Insert(\"test\").Columns(\"name\")\n</code></pre>"},{"location":"reference/go/query/#values","title":"Values","text":"<p>Values sets the insert data.</p> <pre><code>values := []map[string]interface{}{{\"name\": \"John\"}}\nb.Query().Insert(\"test\").Columns(\"name\").Values(values)\n</code></pre>"},{"location":"reference/go/query/#lastinsertedid","title":"LastInsertedID","text":"<p>LastInsertedID gets the last id over different drivers. The first argument must be a ptr to the value field. The second argument should be the name of the ID column - if needed.</p> <pre><code>var id int\nb.Query().Insert(\"test\").Columns(\"name\").LastInsertedID(&amp;id)\n</code></pre>"},{"location":"reference/go/query/#string_1","title":"String","text":"<p>String returns the rendered statement and arguments.</p> <pre><code>values := []map[string]interface{}{{\"name\": \"John\"}}\nb.Query().Insert(\"test\").Columns(\"name\").Values(values).String()\n</code></pre>"},{"location":"reference/go/query/#exec","title":"Exec","text":"<p>Exec the statement. It will return a slice of <code>[]sql.Result</code> because it could have been batched.</p> <pre><code>values := []map[string]interface{}{{\"name\": \"John\"}}\nres, err := b.Query().Insert(\"test\").Columns(\"name\").Values(values).Exec()\n</code></pre>"},{"location":"reference/go/query/#update","title":"Update","text":""},{"location":"reference/go/query/#columns_2","title":"Columns","text":"<p>Columns define a fixed column order for the insert. If the columns are not set manually, all keys of the Values will be added. Only Values will be inserted which are defined here. This means, you can use Columns as a whitelist.</p> <pre><code>b.Query().Update(\"test\").Columns(\"name\")\n</code></pre>"},{"location":"reference/go/query/#set","title":"Set","text":"<p>Set the values.</p> <pre><code>b.Query().Update(\"test\").Set(map[string]interface{}{\"name\": \"John\"})\n</code></pre>"},{"location":"reference/go/query/#where_1","title":"Where","text":"<p>Where wraps the <code>condition.SetWhere()</code> function. For more details see condition section.</p> <pre><code>b.Query().Update(\"test\").Set(map[string]interface{}{\"name\": \"John\"}).Where(\"id = ?\", 1)\n</code></pre>"},{"location":"reference/go/query/#condition_1","title":"Condition","text":"<p>Condition adds your own condition to the query.</p> <pre><code>c := condition.New().SetWhere(\"id = ?\", 1)\nb.Query().Update(\"test\").Set(map[string]interface{}{\"name\": \"John\"}).Condition(c)\n</code></pre>"},{"location":"reference/go/query/#string_2","title":"String","text":"<p>String returns the rendered statement and arguments.</p> <pre><code>sql, args, err := b.Query().Update(\"test\").Set(map[string]interface{}{\"name\": \"John\"}).String()\n</code></pre>"},{"location":"reference/go/query/#exec_1","title":"Exec","text":"<p>Exec the statement. It will return a <code>sql.Result</code>.</p> <pre><code>res, err := b.Query().Update(\"test\").Set(map[string]interface{}{\"name\": \"John\"}).Exec()\n</code></pre>"},{"location":"reference/go/query/#delete","title":"Delete","text":""},{"location":"reference/go/query/#where_2","title":"Where","text":"<p>Where wraps the <code>condition.SetWhere()</code> function. For more details see condition section.</p> <pre><code>b.Query().Delete(\"test\").Where(\"id = ?\", 1)\n</code></pre>"},{"location":"reference/go/query/#condition_2","title":"Condition","text":"<p>Condition adds your own condition to the query.</p> <pre><code>c := condition.New().SetWhere(\"id = ?\", 1)\nb.Query().Delete(\"test\").Condition(c)\n</code></pre>"},{"location":"reference/go/query/#string_3","title":"String","text":"<p>String returns the rendered statement and arguments.</p> <pre><code>sql, args, err := b.Query().Delete(\"test\").String()\n</code></pre>"},{"location":"reference/go/query/#exec_2","title":"Exec","text":"<p>Exec the statement. It will return a <code>sql.Result</code>.</p> <pre><code>res, err := b.Query().Delete(\"test\").Exec()\n</code></pre>"},{"location":"reference/go/query/#information","title":"Information","text":""},{"location":"reference/go/query/#describe","title":"Describe","text":"<p>Describe the defined table.</p> <pre><code>// all columns\ncols, err := b.Query().Information(\"test\").Describe()\n\n// only some columns\ncols, err := b.Query().Information(\"test\").Describe(\"name\", \"surname\")\n</code></pre>"},{"location":"reference/go/query/#foreignkey","title":"ForeignKey","text":"<p>ForeignKey will return the foreign keys for the defined table.</p> <pre><code>fks, err := b.Query().Information(\"test\").ForeignKey()\n</code></pre>"},{"location":"reference/go/query/#dbexpr","title":"DbExpr","text":"<p>DBExpr is a helper to avoid quoting. Every string which is wrapped in <code>query.DbExrp(\"test\")</code> will not get quoted by the builder.</p>"},{"location":"reference/go/query/#condition_3","title":"Condition","text":"<p>Condition provides a sql condition builder. The placeholder <code>?</code> must be used and will automatically replaced with the driver placeholder later on.</p>"},{"location":"reference/go/query/#new_1","title":"New","text":"<p>Will create a new condition instance.</p> <pre><code>c := condition.New()\n</code></pre>"},{"location":"reference/go/query/#setjoin-join","title":"SetJoin, Join","text":"<p>SetJoin will create a sql JOIN condition. <code>LEFT</code>, <code>RIGHT</code>, <code>INNER</code> and <code>CROSS</code> are supported. SQL USING() is not supported at the moment. If the join type is unknown or the table is empty, an error will be set.</p> <pre><code>c.SetJoin(condition.LEFT,\"users\",\"users.id = ?\",1)\n</code></pre> <p>Join will return the defined conditions as <code>condition.Clause</code>. On a clause, you can receive the condition and passed arguments.</p> <pre><code>clauses := c.Join()\nclause[0].Condition() // would return `JOIN LEFT users ON users.id = ?`\nclause[0].Arguments() // would return `[]int{1}`\n</code></pre>"},{"location":"reference/go/query/#setwhere-where","title":"SetWhere, Where","text":"<p>SetWhere will create a sql WHERE condition. When called multiple times, its getting chained by AND operator.</p> <p>Arrays and slices can be passed as argument.</p> <pre><code>c.SetWhere(\"id = ? AND name = ?\",1,\"John\")\nc.SetWhere(\"id IN (?)\",[]int{10,11,12}) // will render the condition into `id IN (?, ?, ?)`\n</code></pre> <p>Where will return the defined conditions as <code>condition.Clause</code>. On a clause, you can receive the condition and passed arguments.</p> <pre><code>clauses := c.Where()\nclause[1].Condition() // would return `id IN (?, ?, ?)`\nclause[1].Arguments() // would return `[]int{10,11,12}`\n</code></pre>"},{"location":"reference/go/query/#setgroup-group","title":"SetGroup, Group","text":"<p>SetGroup should only be called once. If it's called more often, the last values are set.</p> <pre><code>c.SetGroup(\"id\",\"name\")\n</code></pre> <p>Group will return a slice of a string with all the added values.</p>"},{"location":"reference/go/query/#sethaving-having","title":"SetHaving, Having","text":"<p><code>SetHaving</code> and <code>Having</code> have the same functionality as <code>SetWhere</code> and <code>Where</code>.</p>"},{"location":"reference/go/query/#setorder-order","title":"SetOrder, Order","text":"<p>SetOrder should only be called once. If a column has a <code>-</code> prefix, DESC order will get set. If it's called more often, the last values are set.</p> <pre><code>c.SetOrder(\"name\", \"-surname\") // rendered into `ORDER BY name ASC, surname DESC`\n</code></pre>"},{"location":"reference/go/query/#setlimit-limit","title":"SetLimit, Limit","text":"<p>Set or get the sql <code>LIMIT</code>.</p> <pre><code>c.SetLimit(10)\n</code></pre>"},{"location":"reference/go/query/#setoffset-offset","title":"SetOffset, Offset","text":"<p>Set or get the sql <code>OFFSET</code>.</p> <pre><code>c.SetOffset(2)\n</code></pre>"},{"location":"reference/go/query/#reset","title":"Reset","text":"<p>Reset the complete condition or only single parts.</p> <pre><code>// complete condition will be reset.\nc.Reset()\n\n// only the WHERE conditions will be reset.\nc.Reset(condition.Where)\n</code></pre>"},{"location":"reference/go/query/#merge","title":"Merge","text":"<p>Merge two conditions. <code>Group</code>, <code>Offset</code>, <code>Limit</code> and <code>Order</code> will be set if they have a none zero value instead of merged, because they should only be used once. <code>Where</code>, <code>Having</code> and <code>Join</code> will be merged, if exist.</p> <pre><code>a := conditon.New()\n// ...\nb := condition.New()\n// ...\n\na.Merge(b)\n</code></pre>"},{"location":"reference/go/query/#replaceplaceholders","title":"ReplacePlaceholders","text":"<p>ReplacePlaceholders is a helper function to replace the <code>condition.Placholder</code> <code>?</code> with any other placeholder.</p> <pre><code>condition.ReplacePlaceholders(\"id = ? AND name = ?\", Placeholder{Char:\"$\", Numeric:true})\n// will return `id = $1 AND name = $2`\n</code></pre>"},{"location":"reference/go/query/#config_1","title":"Config","text":"<p>The basic sql config is required. If a provider needs some additional configuration, its no problem to embed this struct but the providers function <code>Config()</code> must return this struct.</p> <pre><code>type Config struct {\nUsername string\nPassword string\nHost     string\nPort     int\nDatabase string\n\nMaxIdleConnections int\nMaxOpenConnections int\nMaxConnLifetime    time.Duration\nTimeout            string\n\nPreQuery []string\n}\n</code></pre>"},{"location":"reference/go/query/#providers","title":"Providers","text":""},{"location":"reference/go/query/#mysql","title":"Mysql","text":"<p>Mysql Provider which uses <code>github.com/go-sql-driver/mysql</code> under the hood.</p> <p>Time structs will be parsed and a timeout limit is set to 30s by default.</p>"},{"location":"reference/go/query/#usage_1","title":"Usage:","text":"<pre><code>import \"github.com/patrickascher/gofer/query\"\nimport _ \"github.com/patrickascher/gofer/query/mysql\"\n\nquery.New(\"mysql\", config)\n</code></pre>"},{"location":"reference/go/registry/","title":"Registry","text":"<p>Package registry provides a simple container for values in the application space.</p>"},{"location":"reference/go/registry/#usage","title":"Usage","text":"<p>The registry name <code>string</code> and registry value <code>interface{}</code> argument must have a non-zero value, and the registered name must be unique, otherwise an error will return.</p> <p>If a validator is registered, and the registry name matches any <code>Validate.Prefix</code>, it will be checked against <code>Validate.Fn</code> before the value will be added to the registry.</p>"},{"location":"reference/go/registry/#set","title":"Set","text":"<pre><code>import \"github.com/patrickascher/gofer/registry\"\n\nerr := registry.Set(\"Version\",\"0.1\")\n</code></pre>"},{"location":"reference/go/registry/#get","title":"Get","text":"<pre><code>import \"github.com/patrickascher/gofer/registry\"\n\nvalue,err := registry.Get(\"Version\")\n// Output value\n// 0.1\n</code></pre>"},{"location":"reference/go/registry/#prefix","title":"Prefix","text":"<p>Prefix will return all entries which name starts with the given prefix.</p> <pre><code>import \"github.com/patrickascher/gofer/registry\"\nerr := registry.Set(\"export_json\",\"\")\n\nvalues := registry.Prefix(\"export_\")\n//...\n</code></pre>"},{"location":"reference/go/registry/#validator","title":"Validator","text":"<p>Because of the value type <code>interface{}</code>, any type can be registered as value. Sometimes it makes sense to check the value before its getting added (e.g. against a type).</p> <p>The <code>Validator</code> function requires a <code>Validate</code> struct as argument. It must be defined with <code>Validate.Prefix string</code> and  <code>Validate.Fn func(name string, value interface{}) error</code>.</p> <p>The <code>Validate.Prefix</code> must be unique, otherwise an error will return. The <code>Validate.Fn</code> will receive the registry name and registry value as arguments.</p> <p>Now before any value will be added to the registry, it will be checked against the <code>Validate.Fn</code> if the registry name matches the <code>Validate.Prefix</code>.</p> <pre><code>import \"github.com/patrickascher/gofer/registry\"\n\nerr = registry.Validator(registry.Validate{Prefix: \"test_\", Fn: func(name string, value interface{}) error {\n        if reflect.TypeOf(value).Kind() != reflect.String {\n            return errors.New(\"wrong type\")\n        }\n        return nil\n    }})\n//...\n\n// test_foo matches the registeres prefix test_. \n// The custom type check is ok.\nerr := registry.Set(\"test_foo\",\"ok\")\n//... \n\n// test_bar matches the registeres prefix test_.\n// The custom type check throws an error, because its no string.\nerr := registry.Set(\"test_bar\",false)\n// ...\n</code></pre>"},{"location":"reference/go/registry/#examples","title":"Examples","text":""},{"location":"reference/go/registry/#type-casting","title":"Type casting","text":"<p>You can add any type as value, as long as it is not nil. In the following example we are going to add a function as value.</p> <p>Tip</p> <p>If you are adding a function as reference (without braces), the variables/objects of the function will only be allocated on function call. Like this, the memory will only be allocated, when needed!</p> <pre><code>import \"github.com/patrickascher/gofer/registry\"\n\ntype Config struct{\n    Debug bool\n}\n\n// The function we are going to add\nfunc Debug(cfg Config) bool {\n    return cfg.Debug\n}\n\n// set the new registry \"dummyFunc\" with the function as reference\nerr := registry.Set(\"dummyFunc\",New)\n//...\n\n// getting the \"dummyFunc\" registry\nfn,err := registry.Get(\"dummyFunc\")\n//...\n\n// casting the function and call it with the config argument\noutput = fn.(func(Config) bool)(Config{Debug:true})\n// output: true\n</code></pre>"},{"location":"reference/go/router/","title":"Router","text":"<p>Package router provides a manager to add public and secure routes based on a <code>http.Handler</code> or <code>http.HandlerFunc</code>.</p> <p>Specific Action&lt;-&gt;HTTP Method mapping can be defined.</p> <p>Middleware can be added for each route or globally for all secured routes.</p> <p>Files or directories can be added.</p> <p>The <code>PATTERN</code>, <code>PARAMS</code>, <code>ACTION</code> and (<code>ALLOWED</code> HTTP Methods - only on OPTIONS) will be added as request context.</p>"},{"location":"reference/go/router/#usage","title":"Usage","text":"<p>Inspired by the <code>database/sql</code>, this module is based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section.</p> <pre><code>import \"github.com/patrickascher/gofer/router\"\nimport _ \"github.com/patrickascher/gofer/router/httprouter\" // example for the julienschmidt http router\n</code></pre>"},{"location":"reference/go/router/#new","title":"New","text":"<p>The New function requires two arguments. First the name of the registered provider and a provider configuration. Each provider will have different configuration settings, please see the providers section for more details.</p> <pre><code>// get a new router instance.\nrouterManager,err := router.New(router.JSROUTER,nil)\n</code></pre>"},{"location":"reference/go/router/#allowhttpmethod","title":"AllowHTTPMethod","text":"<p>Can be used to disable one or more HTTP methods globally. By Default: <code>TRACE</code> and <code>CONNECT</code> are disabled.</p> <pre><code>// will disable globally HTTP GET for any routes.\nerr = routerManager.AllowHTTPMethod(http.MethodGet,false)\n</code></pre>"},{"location":"reference/go/router/#setsecuremiddleware","title":"SetSecureMiddleware","text":"<p>Middleware(s) can be added. They will automatically apply to the <code>AddSecureRoute</code>(s).</p> <pre><code>routerManager.SetSecureMiddleware(mw)\n</code></pre>"},{"location":"reference/go/router/#setfavicon","title":"SetFavicon","text":"<p>Sets the fav icon. The pattern is <code>/favicon.ico</code>. If the source does not exist, an error will return.</p> <pre><code>err := routerManager.SetFavicon(\"assets/img/favicon.ico\")\n</code></pre>"},{"location":"reference/go/router/#addpublicfile","title":"AddPublicFile","text":"<p>The first argument is the pattern, and the second one is the source. The pattern must begin with a <code>/</code>. If the pattern already exists, or the source does not exist, an error will return.</p> <pre><code>err := routerManager.AddPublicFile(\"/robot.txt\",\"assets/static/robot.txt\")\n</code></pre>"},{"location":"reference/go/router/#addpublicdir","title":"AddPublicDir","text":"<p>The first argument is the pattern, and the second one is the source. Directories are not allowed on pattern root level <code>/</code>. The pattern must begin with a <code>/</code>. If the pattern already exists, or the source does not exist, an error will return.</p> <pre><code>err := routerManager.AddPublicDir(\"/images\",\"assets/img\")\n</code></pre>"},{"location":"reference/go/router/#addpublicroute","title":"AddPublicRoute","text":"<p>A route can be added to the router. Please see the route section for more details.</p> <pre><code>err := routerManager.AddPublicRoute(router.NewRoute(\"/login\", handleFunc))\n</code></pre>"},{"location":"reference/go/router/#addsecureroute","title":"AddSecureRoute","text":"<p>A secure route can be added to the router. Please see the route section for more details. The route secure variable will be set to <code>true</code></p> <p>If no secure middleware(s) are defined, an error will return.</p> <pre><code>err := routerManager.AddSecureRoute(router.NewRoute(\"/admin\", handleFunc))\n</code></pre>"},{"location":"reference/go/router/#routes","title":"Routes","text":"<p>All defined routes of the router will return.</p> <pre><code>routes := routerManager.Routes()\n</code></pre>"},{"location":"reference/go/router/#routebypattern","title":"RouteByPattern","text":"<p>The route by the given pattern will return. If the pattern does not exist, an error will return.</p> <pre><code>routes := routerManager.RouteByPattern(\"/favicon.ico\")\n</code></pre>"},{"location":"reference/go/router/#handler","title":"Handler","text":"<p>Returns the <code>http.Handler</code>.</p> <pre><code>handler := routerManager.Handler()\n</code></pre>"},{"location":"reference/go/router/#setnotfound","title":"SetNotFound","text":"<p>Set a custom handler for all routes which can not be found.</p> <pre><code>routerManager.SetNotFound(hanlder)\n</code></pre>"},{"location":"reference/go/router/#route","title":"Route","text":"<p>A new route can be created with <code>router.NewRoute(pattern string, handler interface{}, mapping ...Mapping)</code>.</p> <p><code>patter</code>: If the pattern already exists, an error will return.</p> <p><code>handler</code> can be of type <code>http.Handler</code> or <code>http.HandlerFunc</code>. If it is <code>nil</code> or any other type, an error will return.</p> <p>A action name mapping is required on <code>http.Handler</code>. Mappings can be defined optionally on <code>http.HandlerFunc</code>. By default, all allowed HTTP methods of the router, will be mapped.</p> <p>A Mapping instance can be created with <code>router.NewMapping(methods []string, action interface{}, mw *middleware)</code>.</p> <p>The <code>methods</code> are any HTTP methods which should be mapped to the pattern. If its nil, all allowed HTTP methods of the router manager will be added.</p> <p>The <code>action</code> can be of the type <code>string</code> or <code>func</code>. If the type is <code>func</code>, the function name will be set as string on runtime. The action string will be added as request context.</p> <p>If set, the <code>middlewares</code> will be added to the route.</p> <p>For each pattern, any HTTP method must be unique, otherwise an error will return.</p> <pre><code>route := router.NewRoute(\"/public2\", handleFunc, router.NewMapping([]string{http.MethodGet}, \"View\", nil), router.NewMapping([]string{http.MethodPUt}, \"Create\", nil))\n</code></pre>"},{"location":"reference/go/router/#middleware","title":"Middleware","text":"<p>All pre-defined middleware:</p>"},{"location":"reference/go/router/#logger","title":"Logger","text":"<p>Provides a middleware for the <code>logger.Manager</code>. The logged information is remoteAddr, HTTP Method, URL, Proto, HTTP Status, Response size and requested time. On HTTP status &lt; 400 a <code>log.Info()</code> will be called otherwise <code>log.Error()</code>.</p> <p>Info</p> <p>The logger middleware should used before all other middlewares, otherwise the request time will be incorrect.</p> <pre><code>// the middleware\nmw := router.NewMiddleware(middleware.NewLogger(logManager).MW)\n</code></pre>"},{"location":"reference/go/router/#jwt","title":"JWT","text":"<p>Provides a middleware to check against a JWT token. If the JWT token is invalid a <code>http.StatusUnauthorized</code> will return. If the JWT token is expired it will be re-generated if allowed. In such case, the request header will be manipulated if a refresh happens, so that there is the new refresh token as <code>REFRESH</code> cookie and the old one as <code>REFRESH_OLD</code>.</p> <p>There are two callback functions. <code>CallbackGenerate</code> for manipulating the claim before its signed. <code>CallbackRefresh</code> to check if the refresh token is still valid, against a custom logic.</p> <p>The claim will be set as request context with the key <code>jwt.CLAIM</code>.</p> <p>A claim struct is provided and can be embedded into a custom struct.</p> <pre><code>cfg := jwt.Config{\n    Alg: jwt.HS512, \n    Issuer: \"authserver\", \n    Audience: \"client\", \n    Subject: \"auth\", \n    Expiration: 5*time.Minute, \n    SignKey: \"secret\",\n    RefreshToken: jwt.RefreshConfig{Expiration: 30*24*time.Hour}\n}\n\nclaim := jwt.Claim{}\n\njwt := jwt.New(cfg,claim);\njwt.CallbackRefresh = func(http.ResponseWriter, *http.Request, Claimer){return nil}  // your logic\njwt.CallbackGenerate = func(http.ResponseWriter, *http.Request, Claimer){return nil} // your logic\n\n// the middleware\nmw := router.NewMiddleware(jwt.MW)\n</code></pre>"},{"location":"reference/go/router/#rbac","title":"RBAC","text":"<p>Provides a role based access control list. It is build on top of the JWT middleware.</p> <p>A RoleService must be set, to check against the custom logic. Simply implement the <code>RoleService</code> interface. The arguments <code>pattern</code> <code>HTTP method</code> and <code>claim</code> will be passed to the <code>Allowed</code> function.</p> <p>Info</p> <p>The JWT middleware must be set before the RBAC middleware.</p> <pre><code>roleService := CustomService{};\nrbac := middleware.NewRbac(roleService)\n\n// the middleware\nmw := router.NewMiddleware(jwt.MW, rbac.MW)\n</code></pre>"},{"location":"reference/go/router/#providers","title":"Providers","text":"<p>All pre-defined providers:</p>"},{"location":"reference/go/router/#jsrouter","title":"JSROUTER","text":"<p>A wrapper for httprouter.</p> <p>Name:</p> <p><code>router.JSROUTER</code></p> <p>Options:</p> <p>no options are available at the moment.</p> <p>Usage:</p> <pre><code>import \"github.com/patrickascher/gofer/router\"\nimport _ \"github.com/patrickascher/gofer/router/jsrouter\"\n\nr,err := router.New(router.JSROUTER,nil)\n</code></pre>"},{"location":"reference/go/router/#create-your-own-provider","title":"Create your own provider","text":"<p>To create your own provider, you have to implement the <code>router.Provider</code> interface.</p> <pre><code>// Provider interface.\ntype Provider interface {\n// Handler must return the mux for http/server.\nHandler() http.Handler\n// custom NotFound handler can be set.\nSetNotFound(http.Handler)\n// AddRoute to the router.\nAddRoute(Route) error\n// AddPublicDir to the router.\n// The source is already checked if it exists.\nAddPublicDir(url string, path string) error\n// AddPublicFile to the router\n// The source is already checked if it exists.\nAddPublicFile(url string, path string) error\n}\n</code></pre> <p>Use the <code>init</code> function to register your provider.</p> <p>The registered value must be of the type <code>func(m Manager, options interface{}) (router.Provider, error)</code>.</p> <pre><code>// init register your config provider\nfunc init() {\n    //...\n    err := router.Register(\"my-provider\",New)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\nfunc New(m Manager, options interface{}) (router.Provider, error){\n    //...\n    return provider,nil\n}\n</code></pre> <p>Usage</p> <pre><code>import \"github.com/patrickascher/gofer/router\"\nimport _ \"your/repo/router/yourProvider\"\n\nerr := router.New(\"my-provider\", options)\n</code></pre>"},{"location":"reference/go/scheduler/","title":"Scheduler","text":"<p>Package scheduler provides a job scheduler for periodically functions.</p>"},{"location":"reference/go/scheduler/#new","title":"New","text":"<p>Will create a new scheduler by the given provider.</p> <p>The second param will be the option parameter. It depends on the provider which options are available. Please see the provider section.</p> <p>The given times, are in <code>time.UTC</code> by default.</p> <pre><code>s, err := scheduler.New(scheduler.GoCron, nil)\nif err != nil {\npanic(err)\n}\nerr = s.Every(1).Minute().Name(\"Test\").Tag(\"Import\").Do(func (){\nfmt.Println(\"croncall:\")\n})\ns.Start() \n</code></pre>"},{"location":"reference/go/scheduler/#start","title":"Start","text":"<p>Will start the scheduler executor in a new routine.</p> <pre><code>s.Start() \n</code></pre>"},{"location":"reference/go/scheduler/#stop","title":"Stop","text":"<p>Will stop the scheduler task runner.</p> <pre><code>s.Stop() \n</code></pre>"},{"location":"reference/go/scheduler/#status","title":"Status","text":"<p>Will return the value <code>Scheduler is running!</code> or <code>Scheduler is not running!</code>.</p> <pre><code>status := s.Status() \n</code></pre>"},{"location":"reference/go/scheduler/#jobs","title":"Jobs","text":"<p>Will return all registered jobs. See Job details for the available methods.</p> <pre><code>jobs := s.Jobs()\n//...\n</code></pre>"},{"location":"reference/go/scheduler/#details","title":"Details","text":"Name Description Name() Will return the name of the job. Will be empty if none was set. Counter() Will return an <code>int</code> with the number of runs. Tags() Returns a <code>[]string</code> with all the given tags. Will be empty if none was set. LastRun() Returns a <code>time.Time</code> for the last run. NextRun() Returns a <code>time.Time</code> for the next run. <pre><code>jobs := s.Jobs()\n\nfor _,job := rang jobs{\nname := job.Name()\ncounter := job.Counter()\nlastRun := job.LastRun()\n//...\n}\n</code></pre>"},{"location":"reference/go/scheduler/#every","title":"Every","text":"<p>Will register a new Job with the given interval.  Interval can be an <code>int</code>, <code>time.Duration</code> or a <code>string</code> that parses with time.ParseDuration(). Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\", \"h\".</p> <p>See Job methods for the available methods.</p>"},{"location":"reference/go/scheduler/#methods","title":"Methods","text":"<p>On Every there are the following methods available.</p> Name Description Second() Second will be set as unit. Minute() Minute will be set as unit. Day() Day will be set as unit. Monday() Will set the unit to week. Tuesday() Will set the unit to week. Wednesday() Will set the unit to week. Thursday() Will set the unit to week. Friday() Will set the unit to week. Saturday() Will set the unit to week. Sunday() Will set the unit to week. Week() Week will be set as unit. TODO: needed? its actually a syn for Monday. Month(...int) Month will be set as unit. If no day is given, 1 will be set as default. At Will define the time when to run. It is only available on <code>Day</code>, <code>Week</code> and <code>Month</code> Formant (HH:MM) or (HH:MM:SS) Name(string) Sets the job name. Tag(...string) Adds tag(s) to the job. Singleton() Singleton will not spawn a new job if the old one is not finished yet. The job will be re-scheduled for the next run. Do(interface{},...interface{}) Do defines the function which should be called. Parameter can be added. <pre><code>// Every minute\nerr := s.Every(1).Minute().Name(\"Test\").Tag(\"Import\").Do(func (){})\n// Every hour\nerr = s.Every(1).Hour().Name(\"Test\").Tag(\"Import\").Do(func (){})\n// Every day (default 00:00:00)\nerr = s.Every(1).Day().Name(\"Test\").Tag(\"Import\").Do(func (){})\n// Every second day at 10:30:05\nerr = s.Every(2).Day().At(\"10:30:05\").Name(\"Test\").Tag(\"Import\").Do(func (){})\n// Every week (default monday)\nerr = s.Every(1).Week().At(\"10:30:05\").Name(\"Test\").Tag(\"Import\").Do(func (){})\n// Every week on wednesday\nerr = s.Every(1).Wednesday().Name(\"Test\").Tag(\"Import\").Do(func (){})\n// Every month (default 1.)\nerr = s.Every(1).Month().Name(\"Test\").Tag(\"Import\").Do(func (){})\n// Every month at 15. at 10:30\nerr = s.Every(1).Month(15).At(\"10:30\").Name(\"Test\").Tag(\"Import\").Do(func (){})\n</code></pre>"},{"location":"reference/go/server/","title":"Server","text":"<p>Package server is a configurable webserver with pre-defined hooks.</p>"},{"location":"reference/go/server/#new","title":"New","text":"<p>New will create a new webserver instance. Only one webserver instance can exist.</p> <p>The following hooks will be called:</p> Name Description router If a router provider is defined by config, a new router manager will be created. The Favicon, PublicDir(s) and PublicFile(s)s will be added if defined. databases All defined databases will be saved globally and opened. caches All defined caches will be created and saved globally. translation If a translation provider is defined by config, a new translation manger will be created. By default the translation raw messages for all registered modules, navigations, and controller will be generated. If the <code>JSONFilePath</code> is configured, a JSON file for each defined language will be generated on start. <p>If the configuration <code>Router.CreateDBRoutes</code> is set to <code>true</code>, for each route an db entry will be made.</p> <pre><code>cfg := server.Configuration{}\n//...\n\nerr := server.New(cfg)\n// ...\n</code></pre>"},{"location":"reference/go/server/#config","title":"Config","text":"<p>The server config can be embedded in your application configuration which can be passed to the <code>New</code> function. Error will return if this function is called before a server instance exists.</p> <pre><code>type MyAppConfig struct {\nserver.Configuration `mapstructure:\",squash\"`\nName string\n}\n</code></pre> <p>Within your application you can access your Config by <code>server.Config()</code>. You have to cast the interface to your actual type.</p> <pre><code>config, err := server.Config()\nmyConfig := config.(MyConfig) // cast to ...\n</code></pre>"},{"location":"reference/go/server/#serverconfig","title":"ServerConfig","text":"<p>By this function you will only receive the <code>server.Configuration</code> struct. Error will return if this function is called before a server instance exists.</p> <pre><code>srvConfig, err := server.ServerConfig() \n</code></pre>"},{"location":"reference/go/server/#frontend-config","title":"Frontend config","text":"<p>If the config <code>config.Webserver.FrontendConfigFile</code> has no zero value, all the config field which have the field tag <code>frontend:\"\"</code> will be added.</p> <p>If the tag is present on a struct, all struct fields will be added. To exclude a single field, <code>frontend:\"-\"</code> can be used.</p> <p>A different field name can be definen with <code>frontend:\"yourName\"</code>.</p> <p>A JSON file will be generated with all the defined Fields.</p>"},{"location":"reference/go/server/#start","title":"Start","text":"<p>Will start the webserver. Error will return if this function is called before a server instance exists.</p> <pre><code>err := server.Start()\n// ...\n</code></pre>"},{"location":"reference/go/server/#stop","title":"Stop","text":"<p>Will stop the webserver. Error will return if this function is called before a server instance exists.</p> <pre><code>err := server.Stop()\n// ...\n</code></pre>"},{"location":"reference/go/server/#jwt","title":"JWT","text":"<p>Will return the <code>*jwt.Token</code> of the webserver. Error will return if this function is called before a server instance exists.</p> <pre><code>jwt, err := server.JWT()\n// ...\n</code></pre>"},{"location":"reference/go/server/#setjwt","title":"SetJWT","text":"<p>Set the server jwt token.. Error will return if this function is called before a server instance exists.</p> <pre><code>err := server.SetJWT(jwt)\n// ...\n</code></pre>"},{"location":"reference/go/server/#router","title":"Router","text":"<p>Will return the defined router. Error will return if this function is called before a server instance exists.</p> <pre><code>router, err := server.Router()\n// ...\n</code></pre>"},{"location":"reference/go/server/#caches","title":"Caches","text":"<p>Will return all defined cache managers. Error will return if this function is called before a server instance exists.</p> <pre><code>caches, err := server.Databases()\n// ...\n</code></pre>"},{"location":"reference/go/server/#databases","title":"Databases","text":"<p>Will return all defined databases. The database is globally used and already opened. Error will return if this function is called before a server instance exists.</p> <pre><code>dbs, err := server.Databases()\n// ...\n</code></pre>"},{"location":"reference/go/server/#translation","title":"Translation","text":"<p>Will return a <code>translation.Manager</code>.</p> <pre><code>i18n, err := server.Translation()\n// ...\n</code></pre>"},{"location":"reference/go/slicer/","title":"Slicer","text":"<p>Package slicer providers some util functions for slices.</p>"},{"location":"reference/go/slicer/#interfaceexists","title":"InterfaceExists","text":"<p>Checks if the given interface exists in a slice. If it exists, a the position and a boolean <code>true</code> will return</p> <pre><code>slice := []interface{}{1, 2}\npos, exists := slicer.InterfaceExists(slice, 1)\n// pos: 0, exists:true\n</code></pre>"},{"location":"reference/go/slicer/#stringprefixexists","title":"StringPrefixExists","text":"<p>Checks if the given prefix exists in the string slice. If it exists, a slice with all matched results will return.</p> <pre><code>cache := []string{\"orm_User\", \"orm_Address\"}\nresult := slicer.StringPrefixExists(cache, \"orm_\")\n// result: []string{\"orm_User\", \"orm_Address\"}\n</code></pre>"},{"location":"reference/go/slicer/#stringexists","title":"StringExists","text":"<p>Checks if the given string exists in the string slice. If it exists, the position and a boolean <code>true</code> will return</p> <pre><code>cache := []string{\"orm_User\", \"orm_Address\"}\nresult := slicer.StringPrefixExists(cache, \"orm_User\")\n// result: 0,true\n</code></pre>"},{"location":"reference/go/slicer/#stringunique","title":"StringUnique","text":"<p>Will unique all strings in the given slice.</p> <pre><code>cache := []string{\"orm_User\", \"orm_User\",\"orm_Address\"}\nresult := slicer.StringUnique(cache\n// result:[]string{\"orm_User\", \"orm_Address\"}\n</code></pre>"},{"location":"reference/go/stringer/","title":"Stringer","text":"<p>Package stringer providers some util functions for strings.</p>"},{"location":"reference/go/stringer/#cameltosnake","title":"CamelToSnake","text":"<pre><code>stringer.CamelToSnake(\"GoTestExample\")\n// returns go_test_example\n</code></pre>"},{"location":"reference/go/stringer/#snaketocamel","title":"SnakeToCamel","text":"<pre><code>stringer.CamelToSnake(\"go_test_example\")\n// returns GoTestExample\n</code></pre>"},{"location":"reference/go/stringer/#singular","title":"Singular","text":"<pre><code>stringer.Singular(\"users\")\n// returns user\n</code></pre>"},{"location":"reference/go/stringer/#plural","title":"Plural","text":"<pre><code>stringer.Plural(\"user\")\n// returns users\n</code></pre>"},{"location":"reference/go/structer/","title":"Structer","text":"<p>Package structer providers some util functions for structs.</p>"},{"location":"reference/go/structer/#merge-mergebymap","title":"Merge, MergeByMap","text":"<p>Are functions to merge a s struct by another struct or by a map. It`s a wrapper for mergo. For more the options check out the repository.</p> <p>Info</p> <p>Use <code>mergo.WithOverride</code> options to overwrite dest values.</p> <pre><code>type Foo struct {\n    A string\n    B int\n}\n\nsrc := Foo{\n    A: \"one\",\n    B: 2,\n}\ndest := Foo{\n    A: \"two\",\n}\n\nstructer.Merge(&amp;dest,src)\n// result: A:two, B:2\n</code></pre>"},{"location":"reference/go/structer/#parsetag","title":"ParseTag","text":"<p>ParseTag will parse the tag to key/value pairs <code>map[string]string</code>.</p> <p>Multiple entries can be separated by <code>;</code> Values are optionally.</p> <pre><code>// `orm:primary`            // will be parsed to: map[primary]\"\"\n// `orm:primary; column:id` // will be parsed to: map[column]\"id\"\n\nsfield := reflect.StructField{}\nstructer.ParseTag(field.Tag(\"orm\"))\n</code></pre>"},{"location":"reference/go/translation/","title":"Translation","text":"<p>Package translation provides an i18n implementation for the back- and frontend. For the backend go-i18n is used in the back and for the frontend vue-i18n.</p> <p>See the controller section how to use it in the backend or the frontend section for the frontend.</p>"},{"location":"reference/go/translation/#usage","title":"Usage","text":"<p>Inspired by the <code>database/sql</code>, this module is based on providers. You have to import the needed provider with a dash in front: This will only call the init function(s) of the package(s) and will register itself. For a full list of all available providers, see the providers section.</p> <pre><code>import \"github.com/patrickascher/gofer/locale/translation\"\nimport _ \"github.com/patrickascher/gofer/locale/translation/db\" // example for the database provider\n</code></pre> <p>If you are using the skeleton app, the translation will be added automatically if it's configured in the <code>config.json</code>.</p> <p>Otherwise, you can create a new manager instance like this:</p> <pre><code>manager, err = translation.New(translation.DB, nil, translation.Confgi{DefaultLanguage:\"en\",Controller:true})\n//..\n</code></pre>"},{"location":"reference/go/translation/#add-raw-messages","title":"Add raw messages","text":"<p>To add a raw message, simply use the <code>translation.AddRawMessage</code> function. This must be added at an early stage of the application (before server.Start()). One way is to add it by the <code>init</code> function or before the server is started.</p> <pre><code>func init() {\n    translation.AddRawMessage(i18n.Message{ID: \"Title\", Description: \"The application title\"})\n}\n</code></pre>"},{"location":"reference/go/translation/#config","title":"Config","text":"<pre><code>// Config for the translation.\ntype Config struct {\n    // Controller - if enabled, translations will be available in the controller.\n    Controller bool\n    // JSONFilePath - if not zero, JSON files will be generated for each defined language.\n    JSONFilePath string\n    // DefaultLanguage - Default language of the application.\n    DefaultLanguage string\n}\n</code></pre>"},{"location":"reference/go/translation/#controller","title":"Controller","text":"<p>A controller with a full functional CRUD for the translation is available <code>locale.Controller</code>.</p>"},{"location":"reference/go/translation/#addroutes","title":"AddRoutes","text":"<p>For an easy migration you can use the <code>AddRoutes</code> function to add the translation routes to your router. Two routes will be added:</p> <ul> <li>the CRUD router for the frontend.</li> <li>the added JSON directory (if enabled by config)</li> </ul> <pre><code>locale.AddRoutes(yourRouter)\n</code></pre>"},{"location":"reference/go/translation/#providers","title":"Providers","text":"<p>All pre-defined providers:</p>"},{"location":"reference/go/translation/#db","title":"DB","text":"<p>A wrapper for httprouter.</p> <p>Name:</p> <p><code>translation.DB</code></p> <p>Options:</p> <p>no options are available at the moment.</p> <p>Usage:</p> <pre><code>import \"github.com/patrickascher/gofer/locale/translation\"\nimport _ \"github.com/patrickascher/gofer/locale/translation/db\"\n\nerr := translation.New(translation.DB, nil,translation.Config{})\n</code></pre>"},{"location":"reference/go/translation/#create-your-own-provider","title":"Create your own provider","text":"<p>To create your own provider, you have to implement the <code>translation.Provider</code> interface.</p> <pre><code>// Provider interface.\ntype Provider interface {\nBundle() (*i18n.Bundle, error)\nLanguages() ([]language.Tag, error)\nJSON(path string) error\nAddRawMessage([]i18n.Message) error\nDefaultMessage(id string) *i18n.Message\nSetDefaultLanguage(language.Tag)\n}\n</code></pre> <p>Use the <code>init</code> function to register your provider.</p> <p>The registered value must be of the type <code>func(m Manager, options interface{}) (router.Provider, error)</code>.</p> <pre><code>// init register your config provider\nfunc init() {\n    //...\n    err := translation.Register(\"my-provider\",New)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\nfunc New(m Manager, options interface{}) (translation.Provider, error){\n    //...\n    return provider,nil\n}\n</code></pre> <p>Usage</p> <pre><code>import \"github.com/patrickascher/gofer/router\"\nimport _ \"your/repo/router/yourProvider\"\n\nerr := translation.New(\"my-provider\", nil,translation.Config{})\n</code></pre>"}]}